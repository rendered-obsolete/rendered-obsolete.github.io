---
layout: post
title: rustlang dynamic library
date: '2016-03-21T10:17:00.002+09:00'
author: 'Contact:'
tags:
- rustlang
- ffi
modified_time: '2016-03-21T10:36:16.659+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-4835835019702466685
blogger_orig_url: http://rendered-obsolete.blogspot.com/2016/03/rustlang-dynamic-library.html
---

Was wanting to figure out how to do a rust dynamic library because I've been thinking about how I could apply software updates to a running system.  I came across <a href="https://doc.rust-lang.org/std/dynamic_lib/struct.DynamicLibrary.html">dynamic_lib</a> which is apparently deprecated and replaced with <a href="https://crates.io/crates/dylib">dylib</a> (with the same <a href="https://tomaka.github.io/glium/dylib/struct.DynamicLibrary.html">api</a>), but there's still fairly little documentation.  Pretty much the only simple working example I was able to find was <a href="http://stackoverflow.com/questions/26688575/manually-call-a-rust-dynamic-library">this StackOverflow question</a>.  But it's from over a year ago and predates even rust 1.0 (I'm currently using 1.7).  <p/> To start off, use <a href="http://doc.crates.io/guide.html">cargo</a> to setup two projects; one for the library itself, another for the executable that uses it:  <pre><br />cargo new dynamiclib<br />cargo new --bin dynamic<br />cd dynamiclib<br /></pre> Add the following to dynamiclib's Cargo.toml: <pre><br />[lib]<br />crate-type = ["dylib"]<br /></pre> Setting the crate-type to "dylib" means a dynamic library will be built (rather than an executable or static library).  Save the following as src/lib.rs: <pre><br />#[no_mangle]<br />pub extern "C" fn test() -> u32 {<br />    47<br />}<br /></pre> And build the library by running: <pre><br />cargo build<br /></pre> Next, we need to create the executable that loads and uses the library we just created.  Add the following to dynamic/Cargo.toml: <pre><br />[dependencies]<br />dylib = "0.0.2"<br /></pre> And save the following as dynamic/src/main.rs: <pre><br />extern crate dylib;<br />use dylib::DynamicLibrary;<br />use std::path::Path;<br /><br />fn main() {<br />    // I'm on OSX, obviously<br />    match DynamicLibrary::open(Some(Path::new("libdynamiclib.dylib"))) {<br />        Ok(lib) => {<br />            let test = unsafe {<br />                let ptr = lib.symbol::<u32>("test").unwrap();<br />                println!("Found it: {:?}", ptr);<br />                std::mem::transmute::<_, fn() -> u32>(ptr)<br />            };<br />            println!("Got: {}", test());<br />        },<br />        Err(e) => println!("Failed: {}", e)<br />    }<br />}<br /></pre> I eventually came across <a href="http://oppenlander.me/articles/rust-ffi">this post</a> that's about calling rust from Node.js, and it made me realise that dylib is just a wrapper around <a href="http://doc.rust-lang.org/book/ffi.html">Foreign Function Interface (FFI)</a> (as opposed to some special/magical functionality provided by the runtime or a core library).  This is easily confirmed if you check the <a href="https://github.com/Kintaro/rust-dylib/blob/master/src/lib.rs">dylib source</a>; it just uses libc to call dlopen and kin.  That means that rather than using prepend_search_path to ensure the dynamic library can be found, you can set LD_LIBRARY_PATH to the output path of dynamiclib (e.g. $HOME/dynamiclib/target/release).  Allowing you to build and run the executable with: <pre><br />LD_LIBRARY_PATH=$HOME/dynamiclib/target/release crate run<br /></pre> I'm admittedly a little bit disappointed that dynamic libraries are so painfully close to native interop preventing idiomatic implementations that transparently work like native code.  Something a bit more like the <em>magic</em> in .Net- but that would bring the runtime nastiness that rust tries so hard to avoid.  <p/> It's worth noting that if you have no intention of re-loading the dynamic library and you simply want to link with it, I could have changed dynamic/src/main.rs to: <pre><br />#[link(name="dynamiclib")]<br />extern {<br />    fn test() -> u32;<br />}<br /><br />fn main() {<br />    println!("Got: {}", unsafe { test() });<br />}<br /></pre> Now dynamiclib needs to be in one of the locations that rust searches for libraries (e.g. dynamic/target/debug) at <em>build</em> time.