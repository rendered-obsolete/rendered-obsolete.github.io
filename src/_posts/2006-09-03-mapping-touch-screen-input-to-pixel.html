---
layout: post
title: Mapping touch-screen input to pixel values on the DS
date: '2006-09-03T02:42:00.000+09:00'
author: 'Contact:'
tags:
- nds
- dev
- devkitpro
modified_time: '2006-09-03T03:08:46.078+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-6386999103796942563
blogger_orig_url: http://rendered-obsolete.blogspot.com/2006/09/mapping-touch-screen-input-to-pixel.html
---

Finally got some school stuff out of the way so I can get back to the important things in life.... like the Nintendo DS.<br /><br />Been messing around with touch-screen input a bit.  It was fairly easy to get a demo running, but when I started trying to drag something around I found out that the touch screen uses a different coordinate system from the display.  Dug around a little bit and came up with:<br /><br /><pre class="code"><br />#define SCREEN_WIDTH   256<br />#define SCREEN_HEIGHT   192<br /><br />// those are pixel positions of the two points you click <br />// when calibrating<br />#define TOUCH_CNTRL_X1   (*(vu8*)0x027FFCDC)<br />#define TOUCH_CNTRL_Y1   (*(vu8*)0x027FFCDD)<br />#define TOUCH_CNTRL_X2   (*(vu8*)0x027FFCE2)<br />#define TOUCH_CNTRL_Y2   (*(vu8*)0x027FFCE3)<br /><br />// those are the corresponding touchscreen values:<br />#define TOUCH_CAL_X1   (*(vu16*)0x027FFCD8)<br />#define TOUCH_CAL_Y1   (*(vu16*)0x027FFCDA)<br />#define TOUCH_CAL_X2   (*(vu16*)0x027FFCDE)<br />#define TOUCH_CAL_Y2   (*(vu16*)0x027FFCE0)<br /><br />// linear mapping can be used to go from touchscreen position to <br />// pixel position<br /><br />// precalculate some values<br />static int16 TOUCH_WIDTH  = TOUCH_CAL_X2 - TOUCH_CAL_X1;<br />static int16 TOUCH_HEIGHT = TOUCH_CAL_Y2 - TOUCH_CAL_Y1;<br />static int16 CNTRL_WIDTH  = TOUCH_CNTRL_X2 - TOUCH_CNTRL_X1;<br />static int16 CNTRL_HEIGHT = TOUCH_CNTRL_Y2 - TOUCH_CNTRL_Y1;<br /><br /><br />// reading pixel position:<br />int16 x = (IPC->touchX - (int16) TOUCH_CAL_X1) <br />    * CNTRL_WIDTH  / TOUCH_WIDTH  + (int16) TOUCH_CNTRL_X1;<br />int16 y = (IPC->touchY - (int16) TOUCH_CAL_Y1) <br />    * CNTRL_HEIGHT / TOUCH_HEIGHT + (int16) TOUCH_CNTRL_Y1;<br /></pre><br /><br />at <a href="http://www.bottledlight.com/ds/index.php/Misc/TouchScreen">NDSTech Wiki</a>.  The needed calibration values don't seem to be in ndslib so I think you need to define them yourself.  Took around a minute of messing around to get a nice demo working where you could drag something around on screen just like you'd expect.<br /><br />Something I did in my code that's worth pointing out is changing the calculations a bit to get rid of any extra operations (especially the division).  Granted, I'm not sure how much the compiler can take care of, but it probably doesn't hurt.<br /><br />First, if you separate the<br /><pre class="code">IPC->touchX - (int16) TOUCH_CAL_X1<br /></pre>terms, the entire TOUCH_CAL_X1 component only needs to be calculated once.<br /><br />Second, you can trade out the arbitrary divide for a shift by preforming the divide ahead of time and shifting the result to avoid using floating point.  Then undoing the shift whenever you use the value.  The numbers are small enough that you shouldn't have to worry about overflow when multiplying with a larger number... I think.  i.e.<br /><br /><pre class="code"><br />#define SHIFT 4<br />static u16 scale_value = (CNTRL_WIDTH << SHIFT) / TOUCH_WIDTH;<br />...<br />(IPC->touchX * scale_value) >> SHIFT ...<br /></pre><br /><br />Gotta look into compiler optimizations and figure out whether the above is worth the trouble if you specify -O2, etc.