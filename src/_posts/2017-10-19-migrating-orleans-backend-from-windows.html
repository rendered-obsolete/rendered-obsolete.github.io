---
layout: post
title: Migrating Orleans backend from Windows to Linux, AWS, and beyond
date: '2017-10-19T11:16:00.001+09:00'
author: 'Contact:'
tags:
- mono
- '2016'
- linux
- backend
- orleans
modified_time: '2017-10-19T11:16:32.559+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-4173185354068582080
blogger_orig_url: http://rendered-obsolete.blogspot.com/2017/10/migrating-orleans-backend-from-windows.html
---

<b>This is a draft of a post I composed in March, 2016.  Only partially completed, but maybe it will be of some value to someone.</b> <p/> Our backend has been based on Microsoft Orleans (<a href="http://research.microsoft.com/en-us/projects/orleans/">MS Research</a>, <a href="https://github.com/dotnet/orleans">GitHub</a>) for some time.  We're primarily running the entire backend- deployment and all- on Windows 7 mostly because: <ol><li>It's convenient since all developers are running Windows on their desktops</li><li>It's easier for QA to test and operate playtests until everything is fully automated and we've got devops tools in place</li><li>Our company is mostly a "Windows shop" anyway</li></ol> It's been a long time coming, but we've finally gotten around to looking at running the backend on Linux.  A few components, namely <a href="http://zookeeper.apache.org/">Zookeeper</a> and <a href="https://www.mongodb.org/">MongoDB</a> are fairly straight-forward since they're arguably <em>intended</em> to run on Linux.  That leaves Orleans itself and, of course, our own game server.  <p/> Orleans should "in theory" work fine on top of Mono.  However, our Orleans projects are a bit of a mess, so I thought I'd just try running the binaries produced by Visual Studio.  And <a href="https://en.wikipedia.org/wiki/Write_once,_run_anywhere">shockingly (see "...debug everywhere")</a>, it mostly worked; we only ran into the following problems: <ul><li>We use <a href="https://logging.apache.org/log4net/">log4net</a> and our App.config was specifying ColoredConsoleAppender which didn't work on Mono (switched to ConsoleAppender)</li><li>We spawn our game servers using Process.StartInfo.UseShellExecute = true and caused an error "xdg-open: unexpected option ..." (we set UseShellExecute to false on Linux- Windows seems to require it)</li><li>Our config file had a Windows "smell"</li><li>It refused to startup with the version of mono that ships with Ubuntu 14.04, but <a href="http://www.mono-project.com/docs/getting-started/install/linux/#debian-ubuntu-and-derivatives">installing the latest, stable version</a> fixed that</li></ul> Next came getting our game server to compile and run on Linux.  Luckily, our <a href="https://github.com/waf-project/waf">WAF</a>-based build system should "just work" on Linux (in theory).  Most of the compilation and runtime problems fell into just a few categories: <ul><li>Hard-coded windows specific paths and commands</li><li>Paths that were incorrect with a case-sensitive filesystem</li><li>Asserts that were triggered by incomplete implementations</li></ul> <p/> <b><i>N.B.</i>: At the time of writing we were using <a href="https://www.cryengine.com/">CryEngine 5.0</a>.  Since then the WAF buildchain has been retired in favor of <a href="https://cmake.org/">cmake</a></b> <p/> Our initial round of deployment scripts where based on PowerShell 3.o and left a lot to be desired.  PowerShell 3 (as opposed to 1 or 2) was chosen because it provided <a href="https://technet.microsoft.com/en-us/library/jj149006.aspx">disconnected sessions</a> allowing us to execute things on a remote machine and leave them running in the background without leaving a shell connected (or installing as a service).  But, PowerShell 3 isn't installed by default on Windows 7 and then <a href="https://technet.microsoft.com/en-us/library/hh849694.aspx">some</a> <a href="https://technet.microsoft.com/en-us/library/hh849812.aspx">other</a> stuff is needed on remote machines to get remote commands working at all.  Generally speaking, it was the overall idiosyncratic behaviour (Invoke-Command takes PSCredentials but old commands like "net use" don't- and there's apparently no modern replacement), and unfamiliar syntax (passing ArgumentList to Invoke-Command's ScriptBlock) that made the PowerShell prototype take longer than I expected.  And there's still a few things that just don't work.  Granted, I'm a completely new to PowerShell, and like all advanced tools there's a nontrivial learning curve.  PowerShell is without a doubt leaps and bounds better than cmd.exe, and some aspects like getting auto-complete for commands and arguments in the ISE were welcome.  <p/> In a completely unfair comparison (given that I have non-trivial Linux experience), we were able to fully automate deployment to Ubuntu in under a day.  The frustration of Invoke-Command/Credential/InDisconnectedSession was replaced with the relatively straightforward use of <a href="https://en.wikipedia.org/wiki/Secure_Shell">ssh</a> and <a href="https://en.wikipedia.org/wiki/Nohup">nohup</a>.  And, once you get password-less <a href="http://www.linuxproblem.org/art_9.html">ssh</a> and <a href="http://askubuntu.com/questions/192050/how-to-run-sudo-command-with-no-password">sudo</a> setup, and embrace other commands like <a href="https://www.mattcutts.com/blog/a-quick-tutorial-on-screen/">screen</a>, working with multiple remote machines is a breeze.  <p/> All-in-all we were up and running on Ubuntu 14.04, rocking nightly builds in <a href="https://jenkins-ci.org/">Jenkins</a>, deploying to <a href="http://aws.amazon.com/">AWS</a>, and doing playtests within a week. *opens a beer*