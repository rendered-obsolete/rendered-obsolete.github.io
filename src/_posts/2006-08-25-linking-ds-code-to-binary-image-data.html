---
layout: post
title: Linking DS Code to Binary Image Data
date: '2006-08-25T01:23:00.000+09:00'
author: 'Contact:'
tags:
- nds
- dev
- devkitpro
modified_time: '2006-08-25T03:08:17.258+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-38589128560902029
blogger_orig_url: http://rendered-obsolete.blogspot.com/2006/08/linking-ds-code-to-binary-image-data.html
---

Having to deal with sprite/texture/background data is a pretty common task in DS programming.  The best way to do it is to strip any sort of header information and undo compression that is part of many graphics formats so you can just link the binary data along with your code.  The problem is you have to know how to do this.<br /><br />It <a href="http://www.gamedev.net/reference/articles/article1780.asp">looks like a lot of people</a> convert the image to a header file and then #include it in their code.  For small demos this really isn't a big deal, but it's kind of bad once you go beyond loading a single image.  Why?  Since the data is included by the pre-processor you have to recompile it along with your code EVERY time you make a change.<br /><br />I figured out the tools well enough to get around this so I thought I'd share two different ways of doing this.  Anyway, the two methods are:<br /><ol><li><a href="http://beta.blogger.com/post-create.g?blogID=5371326417913853395#source">Image->Source->Binary</a></li><li><a href="http://beta.blogger.com/post-create.g?blogID=5371326417913853395#bin2o">Image->Binary</a></li></ol>The end result is essentially the same, the process is just a little different.<br /><br />Both require a program call <a href="http://www.gbadev.org/tools.php?showinfo=142">gfx2gba</a> from <a href="http://www.gbadev.org/">gbadev.org</a> (NOTE: There are two versions of gfx2gba around, but you want v0.13.  v1.03 is a similar but different program from a different author.  I'm pretty sure you could use it I just won't talk about it here).  This program can read various graphics file formats and extract the image data from them in various ways and seems to be an indespensible part of both GBA and DS development (yes, despite its name it is also useful in DS development because the two platforms have several similarities).<br /><br /><h3><a name="#source">Image->Source->Binary</a></h3><br /><ol><li>Use gfx2gba to convert your image (bmp/pcx/tga/...) to a C source file.  I will assume your image file is called image.bmp.<br /><pre class="code"><br />gfx2gba -t8 -f src -o arm9/source image.bmp<br /></pre><br />This converts image.bmp into a master.pal.c file containing the palette information and a image.raw.c file containing the image data arranged as 8x8 tiles.  This would be used for sprites.  For backgrounds you don't want tiling so you leave off "-t8".<br /><br />"-f src" specifies that the output type will be source (C) files.<br /><br />"-o arm9/source" specifies the output directory that the *.c files will be placed it.  Set this to your source directory.<br /><br />gfx2gba has several other options so be sure to try running it without arguments or looking at the readme.txt file.<br /></li><br /><br /><li>Next, you want to make sure that this image data will be compiled as part of your build process (when you type "make").  You will either have to add it if you are using a custom Makefile, or place it in a directory that is searched for *.c files.<br /></li><br /><br /><li>Finally, you have to make the data accessible from your program.  This is done by adding a declaration to your code so the compiler will let you use the arrays in the external object files.  You will have a palette array called master_Palette in master.pal.c and an image array called image_Bitmap in image.raw.c.  Putting the following code somewhere in your program source code will allow you to use them:<br /><pre class="code"><br />extern const unsigned char image_Bitmap[];<br />extern const unsigned short master_Palette[];<br /></pre><br />Unfortunately, there doesn't seem to be a way to determine the size of the arrays at compile-time when you use this method.  sizeof() gave me an error since they are arrays of unspecified size.  You either have to include the dimension of the arrays from the generated source files:<br /><pre class="code"><br />extern const unsigned char image_Bitmap[4096]; // Or whatever the size is<br />extern const unsigned short master_Palette[256];<br /></pre><br />OR, declare additional variables that hold them:<br /><pre class="code"><br />unsigned int image_Bitmap_size = 4096; // Or whatever<br />unsigned int master_Palette_size = 256;<br /></pre><br />OR, add two other variables to the generated source files to store the size and then declare them as well:<br /><pre class="code"><br />/* Add to the end of image.raw.c */<br />const unsigned int image_Bitmap_size = sizeof( image_Bitmap );<br />/* Add to the end of master.pal.c */<br />const unsigned int master_Palette_size = sizeof( master_Palette );<br /><br />/* In your program source code */<br />extern const unsigned int image_Bitmap_size;<br />extern const unsigned int master_Palette_size;<br />/* Don't forget the data array externs as well */<br /></pre><br />I prefer the latter method because it is the most automatic of the three.  If you ever change the image files you will have to regenerate the source and re-add the lines, but they're quite short and you probably won't be changing the images often.<br /></li><br /></ol><br /><br />Now when you run "make" it will compile the image data source files once and then you won't have to compile them again.  The compiled image data will be linked into the executatable (don't forget to tell the linker about them if necessary).<br /><br />Personally, I don't really like this method because it requires some manual work.  I like things to be as automated as possible so I don't screw something up when I forget to do some manual step.  For this reason I prefer the second method.<br /><br /><h3><a name="#bin2o">Image->Binary</a></h3><br /><ol><br /><li>First, extract the image data from the image file with gfx2gba (assuming an image file called image.bmp):<br /><pre class="code">gfx2gba -f raw -t8 -St.bin -pmaster.bin image.bmp</pre><br />Again, leave off "-t8" if you are working with a background rather than a sprite.<br /><br />"-f raw" for binary output is the default.<br /><br />"-St.bin" sets the extension of the image data to ".bin" instead of the default ".raw".<br /><br />"-pmaster.bin" sets the palette filename to "master.bin" instead of the default ("master.pal").  There is a "-Sp" option to set the palette extension similar to "-St", but it doesn't seem to work.<br /><br />This will generate two binary files: image.bin containing the image data, and master.bin containing the palette.<br /></li><br /><li>Next, you need to make these files linkable.  This requires a bit of "magic" as it's hard to see how the example programs do this.<br /><br />If you look at a Makefile for one of the example programs you will find the following rule way down at the bottom:<br /><pre><br />%.bin.o : %.bin<br />@echo $(notdir $<)  @$(bin2o) </pre><br />Basically, it takes *.bin files and trys to make them *.bin.o files by calling "bin2o".  Now, if you look in devKitPro/devKitARM/base_rules (a file that gets included in all the Makefiles) you will find:<br /><pre class="code"><br />define bin2o<br />bin2s $< | $(AS) $(ARCH) -o $(@)   echo "extern const u8" `(echo $(<f) sed="" e="" 1="" tr="" _="" _end=""> `(echo $(<f) tr="" h="" extern="" const="" u8="" echo=""><f) sed="" e="" 1="" tr="" _="">> `(echo $(<f) tr="" h="" extern="" const="" u32="" echo=""><f) sed="" e="" 1="" tr="" _size="">> `(echo $(<f) tr="" h="" endef=""></f)></f)></f)></f)></f)></f)><br /></pre><br />What this basically does is convert a binary file to assembly language, assemble it so it can be linked to your program, then generates master_bin.h and image_bin.h files to be #include'd in your program source.  They contain:<br /><pre class="code"><br />/* In master_bin.h */<br />extern const u8 master_bin_end[];<br />extern const u8 master_bin[];<br />extern const u32 master_bin_size;<br /><br />/* In image_bin.h */<br />extern const u8 image_bin_end[];<br />extern const u8 image_bin[];<br />extern const u32 image_bin_size;<br /></pre><br /><br />The extern's from the first method all nice and automagically declared for you.<br /></li><br /></ol><br /><br />I've shown you 2 different approaches to getting away from header file #include'd data and moving to more professional linking of binary files.  I prefer the latter method as it can be pretty much completely automated, but which method you use will largely depend on your needs.<br /><br />This is not to say these are the only two methods, mind you.  While trying to figure this all out I saw references to some program named "katie" and another called "bin2c" ("binary to C" I would assume) that sounded like they could likewise be used.  I'll leave that to you.  Also, I'm willing to bet that there's a plugin for <a href="http://www.gimp.org/">The Gimp</a> or some other graphics program that will do all of this.