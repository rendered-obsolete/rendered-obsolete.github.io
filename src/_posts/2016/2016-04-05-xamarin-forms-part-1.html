---
layout: post
title: Xamarin Forms part 1
date: '2016-04-05T19:20:00.001+09:00'
author: 'Contact:'
tags:
- xaml
- c#
- xamarin
- forms
- apps
modified_time: '2016-04-05T19:20:03.711+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-1477542833301547062
blogger_orig_url: http://rendered-obsolete.blogspot.com/2016/04/xamarin-forms-part-1.html
---

This is the first part of my Xamarin Forms dive.  <h2>Binding</h2> Arguably the single most important thing to master as it connects your View (UI) to the ViewModel, it's only fitting I start out with Binding (<a href="https://developer.xamarin.com/guides/xamarin-forms/getting-started/introduction-to-xamarin-forms/#Data_Binding">1</a>, <a href="https://blog.xamarin.com/introduction-to-data-binding/">2</a>  and <a href="https://blog.xamarin.com/advanced-data-binding-for-ios-android-and-windows/">3</a>).  Since I’ve been using Forms I’ve found that binding is key to getting things working but various nuances are scattered about in numerous demos.  <p/> Bindings connect a "source" (either another UI element in the View or something in the ViewModel) to a "target" (some UI element in the View) that displays it.  <p/> To start with, you'll see that most projects create an XML namespace that refers to a .Net assembly generated by your project:  <pre><br />&lt;!-- "xmlns:local" ties "local" XML namespace to the "luck" C# namespace in the "luck" assembly --&gt;<br />&lt;ContentPage<br />    xmlns="http://xamarin.com/schemas/2014/forms"<br />    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"<br />    xmlns:local="clr-namespace:luck;assembly=luck"<br />    x:Class="luck.MainPage"<br />    &gt;<br />&lt;/ContentPage&gt;<br /><br />// "local:MainViewModel" in XAML thus refers to a C# class similar to:<br />namespace luck {<br />    public class MainViewModel {<br />        // Implementation<br />    }<br />}<br /></pre> You can then easily create static bindings, references, and resources:  <pre><br />&lt;!-- Static --&gt;<br />&lt;Label Text="{x:Static local:MainViewModel.Text}" /&gt;<br /><br />// C# ViewModel<br />public class MainViewModel {<br />    public static string Text = "text";<br />}<br /><br />&lt;!-- Reference --&gt;<br />&lt;Label Text="text" x:Name="MyText" /&gt;<br />&lt;Label Text="{x:Reference MyText}" /&gt;<br /><br />&lt;!-- Resource --&gt;<br />    &lt;ContentPage.Resources&gt;<br />        &lt;ResourceDictionary&gt;<br />            &lt;local:LocalizationConverter<br />                x:Key="LocalizationConverter" /&gt;<br />        &lt;/ResourceDictionary&gt;<br />    &lt;/ContentPage.Resources&gt;<br />    &lt;Label Text="{Binding SelectedItem.DisplayName,<br />        Converter={StaticResource LocalizationConverter}}" /&gt;<br /></pre> There's additional information about Resources and markup extensions <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/xaml_markup_extensions/">here</a>, and I'll come back to ResourceDictionary a bit later in this series when I get to Styles.  <p/> Alternatively, the Binding markup extension is the most common binding technique and more advanced as it supports several different properties.  The easiest way of specifying a source is by setting the BindingContext for the entire Page since it is inherited by all children.  This can be done either in your code-behind constructor:  <pre><br />public MainPage ()<br />{<br />     InitializeComponent ();<br />     BindingContext = new MainViewModel (); <br />}<br /></pre> or via XAML:  <pre><br />    &lt;ContentPage.BindingContext&gt;<br />        &lt;local:MainViewModel /&gt;<br />    &lt;/ContentPage.BindingContext&gt;<br /></pre> You can then bind a simple value:  <pre><br />&lt;Label Text="{Binding Text}" /&gt;<br /><br />public class MainViewModel {<br />    public string Text { get; set; }<br />}<br /></pre> As already mentioned, Binding supports several different properties.  <em>Path</em> specifies the property of the source to which we are binding and can be omitted if it's the first property.  The following two are equivalent: <pre><br />&lt;Label Text="{Binding Text}" /&gt;<br />&lt;Label Text="{Binding Path=Text}" /&gt;<br /></pre> The Path property is able to access sub-properties as well as the index operator.  For example: <pre><br />&lt;Label Text="{Binding Values.Count}" /&gt;<br />&lt;Label Text="{Binding Values[key]}" /&gt;<br /><br />// In the ViewModel<br />public Dictionary<string, string> Values { get; set; }<br /></pre> According to <a href="http://forums.xamarin.com/discussion/19361/data-binding-to-dictionary-object">this</a>, if you have large numbers of values to set you can simplify multiple indexed bindings by setting the binding context: <pre><br />&lt;StackLayout BindingContext="{Binding Values}" /&gt;<br />    &lt;Label Text="{Binding [key]}" /&gt;<br />&lt;StackLayout /&gt;<br /></pre> There is also a shorthand syntax to bind directly to the BindingContext itself: <pre><br />&lt;Label Text="{Binding .}" /&gt;<br /></pre> The <em>Source</em> property allows the binding to explicitly specify the "source" of a binding.  It's analogous to the BindingContext (where the target specifies the source) and the following are equivalent:  <pre><br />&lt;Label BindingContext="{x:Reference items}" Text="{Binding SelectedItem, StringFormat='{0}'}" /&gt;<br />&lt;Label Text="{Binding SelectedItem, Source={x:Reference items}, StringFormat='{0}'}" /&gt;<br /></pre> The biggest difference being using BindingContext will be inherited by all sub-children of the UI element.  At one point I found myself repeatedly specifying BindingContext and Source for a number of nested elements and then running into problems where I could no longer reference the original BindingContext, etc.  In this case I had to carefully consider what I was binding where and reorganise the data provided by my ViewModel to cut back on the excessive use of Source.  <p/> <em>StringFormat</em> can be used to apply string conversion and formatting: <pre><br />&lt;Label Text="{Binding Value, StringFormat='Formatted {0}'}" /&gt;<br /></pre> Internally it uses <a href="https://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx">String.Format</a> method so it accepts all the same forms.  Note that because both .Net formatting and markup extensions use curly braces, StringFormat must be enclosed in single quotes.  <p/> The <em>Converter</em> property is more generalised than StringFormat and also accepts an optional <em>ConverterParameter</em> value: <pre><br /> &lt;Label Text="{Binding SomeInt, Converter={StaticResource IntConverter}, ConverterParameter=10}" /&gt;<br /><br /> public class IntConverter : IValueConverter<br /> {<br />  public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)<br />  {<br />   int intparam;<br />   if (!int.TryParse(parameter as string, out intparam))<br />    intparam = 1;<br /><br />   return (int)value * intparam;<br />  }<br /><br />  public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)<br />  {<br />   int intparam;<br />   if (!int.TryParse(parameter as string, out intparam))<br />    intparam = 1;<br /><br />   return ((int)value) / intparam;<br />  }<br /> }<br /></pre> <em>Mode</em> The final property <em>Mode</em> is available to solve some specific binding problems.  I've not done anything with it just yet, so I'll refer to two relevant documents from Xamarin (<a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/data_binding_basics/">1</a>, <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/data_bindings_to_mvvm/">2</a>) and revisit it later when I understand it better.  <h2>Dynamic Bindings</h2> For values that can be changed at runtime, either the property you're binding to or the entire ViewModel needs to implement INotifyPropertyChanged interface.  For example, using System.Collections.ObjectModel.ObservableCollection: <pre><br />public static ObservableCollection<Chat> Chats = new ObservableCollection<Chat>();<br /><br /><ListView ItemsSource="{x:Static local:ChatsViewModel.Chats}" x:Name="Chats" ItemSelected="onItemSelected"><br /></pre> You can even define your own: <pre><br />    public class ObservableString : System.ComponentModel.INotifyPropertyChanged<br />    {<br />        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;<br /><br />        string val;<br />        public string Value<br />        {<br />            get { return val; }<br />            set {<br />                val = value;<br />                OnPropertyChanged ("Value");<br />            }<br />        }<br /><br />        void OnPropertyChanged(string propertyName = null)<br />        {<br />            if (PropertyChanged != null)<br />                PropertyChanged (this, new System.ComponentModel.PropertyChangedEventArgs (propertyName));<br />        }<br />    }<br /></pre> But this only seems to work with static bindings.  The more standard approach is to implement INotifyPropertyChanged for your entire ViewModel:  <pre><br />    public class LoginViewModel : INotifyPropertyChanged<br />    {<br />        bool m_isBusy = false;<br />        public bool IsBusy {<br />            get {<br />                return m_isBusy;<br />            }<br />            set {<br />                if (value != m_isBusy) {<br />                    m_isBusy = value;<br />                    OnPropertyChanged ("IsBusy");<br />                }<br />            }<br />        }<br /><br />        #region INotifyPropertyChanged<br /><br />        public event PropertyChangedEventHandler PropertyChanged;<br /><br />        protected virtual void OnPropertyChanged (string propertyName)<br />        {<br />            var changed = PropertyChanged;<br />            if (changed != null) {<br />                PropertyChanged (this, new PropertyChangedEventArgs (propertyName));<br />            }<br />        }<br />        #endregion<br />    }<br /></pre> With .Net 4.5 OnPropertyChanged can be simplified: <pre><br />        public bool IsBusy {<br />            get {<br />                return m_isBusy;<br />            }<br />            set {<br />                if (value != m_isBusy) {<br />                    m_isBusy = value;<br />                    OnPropertyChanged ();<br />                }<br />            }<br />        }<br /><br />        protected virtual void OnPropertyChanged ([System.Runtime.CompilerServices.CallerMemberName] string propertyName = "")<br />        { /* same as above */ }<br /></pre> A minor improvement, but now the compiler guarantees that the property name always matches the "magic string".  There’s further improvements to reduce all the boilerplate needed to implement properties (specifically <a href="http://danrigby.com/2012/01/08/inotifypropertychanged-the-anders-hejlsberg-way/">this</a>, and more generally like <a href="https://msdn.microsoft.com/en-us/library/bb126445.aspx">this</a> and <a href="https://www.postsharp.net/">this</a>).  <p/> This ran a bit long, but it should wrap up the first dump of my notes on Xamarin Forms.  Next up: Callbacks, Commands, and Triggers... oh my!