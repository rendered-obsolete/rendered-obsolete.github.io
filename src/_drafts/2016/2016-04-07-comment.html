---
layout: post
title: Xamarin Forms part 2
date: '2016-04-07T22:34:00.003+09:00'
author: 'Contact:'
tags:
- xaml
- c#
- xamarin
- forms
- apps
modified_time: '2016-04-07T22:34:47.773+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-3044898507214904912
blogger_orig_url: https://www.blogger.com/comment.g?blogID=5371326417913853395&postID=3044898507214904912
---

<h2>Callbacks/Commands</h2> The simplest example of connecting your XAML to code is by setting a handler for Button’s Clicked event and adding a function to the code-behind class: <pre><br />    &lt;Button Text="Button" Clicked="onClicked" /&gt;<br /><br />    public partial class MainPage : ContentPage<br />    {<br />        async void onClicked(object sender, EventArgs args)<br />        {<br />            await Box.ScaleTo (1.1);<br />            await Box.ScaleTo (1);<br />        }<br />    }<br /></pre> For normally non-interactive elements like the BoxView, you can use a <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/gestures/">GestureRecognizer</a> (the PinchGestureRecognizer mentioned doesn’t seem to exist): <pre><br />        &lt;BoxView x:Name="Box" Color="Blue"&gt;<br />            &lt;BoxView.GestureRecognizers&gt;<br />                &lt;TapGestureRecognizer Tapped="onClicked"/&gt;<br />            &lt;/BoxView.GestureRecognizers&gt;<br />        &lt;/BoxView&gt;<br /></pre> But this is considered bad from an MVVM perspective because it ties your View Model to one particular View.  <p/> This <a href="https://blog.xamarin.com/simplifying-events-with-commanding/">post</a> on the Xamarin blog discusses the MVVM approach- Commands.  <p/> From there it’s easy to change to Commands: <pre><br />        &lt;BoxView x:Name="Box" Color="Blue"&gt;<br />            &lt;BoxView.GestureRecognizers&gt;<br />                &lt;TapGestureRecognizer Command="{Binding Tapped}"/&gt;<br />            &lt;/BoxView.GestureRecognizers&gt;<br />        &lt;/BoxView&gt;<br /><br />        // In MainViewModel implementation<br /><br />        public MainViewModel ()<br />        {<br />            Tapped = new Command (async (obj) => {<br />                // Do something<br />            });<br />        }<br /><br />        public ICommand Tapped { get; private set; }<br /></pre>  The problem is to put the animation directly in the Command, you need access to the private members generated from the XAML.  Out of laziness I wondered if I could just use the code-behind class directly:  <pre><br />    public class MainPage {<br />        public MainPage ()<br />        {<br />            InitializeComponent ();<br />            BindingContext = new MainViewModel (); <br /><br />            var tgr = new TapGestureRecognizer ();<br />            tgr.Tapped += onTapped;<br />            tgr.Command = new Command (async (obj) => {<br />                await Box.ScaleTo (1.1);<br />                await Box.ScaleTo (1);<br />            });<br />            Box.GestureRecognizers.Add (tgr); <br />        }<br />        public ICommand Tapped { get; private set; }<br />    }<br /></pre> But the command wasn’t getting called.  I might have been able to get it working by implementing INotifyPropertyChanged on the code-behind, or some other wizardry, but I figured I was already deep in dubious MVVM territory.  <p/> Ironically, using "MVVM violating” Clicked handlers works perfectly: <pre><br />        &lt;BoxView x:Name="Box" Color="Blue"&gt;<br />            &lt;BoxView.GestureRecognizers&gt;<br />                 &lt;TapGestureRecognizer Tapped="onClicked"/&gt; <br />            &lt;/BoxView.GestureRecognizers&gt;<br />        &lt;/BoxView&gt;<br /><br />    public partial class FiveDicePage : ContentPage<br />    {<br />        async void onClicked(object sender, EventArgs args)<br />        {<br />            await Box.ScaleTo (1.1);<br />            await Box.ScaleTo (1);<br />        }<br />    }<br /></pre> One possibility is to pass the button as a CommandParameter to the Command (similar to the sender argument for the normal Clicked callbacks):  <pre><br />        Tapped = new Command<View> (async (view) => {<br />                await view.ScaleTo (1.1);<br />                await view.ScaleTo (1);<br />        }); <br />        <BoxView x:Name="Box" Color="Blue"><br />            <BoxView.GestureRecognizers><br />                <TapGestureRecognizer Command="{Binding Tapped}" CommandParameter="{Binding Source={x:Reference Box}"/><br />            </BoxView.GestureRecognizers><br />        </BoxView> <br /></pre>  Which, interestingly, works perfectly.  Although it, again seems like a violation of MVVM purity as my View is seeping into my ViewModel.  <p/> Slightly unexpectedly, Button seems to ignore TapGestureRecognizer: <pre><br />    &lt;Button Text="Button" x:Name="Button"&gt;<br />        &lt;Button.GestureRecognizers&gt;<br />                &lt;TapGestureRecognizer Tapped="onTapped" /&gt;<br />        &lt;/Button.GestureRecognizers&gt;<br />    &lt;/Button&gt;<br /><br />    var tgr = new TapGestureRecognizer ();<br />    tgr.Tapped += onTapped;<br />    Button.GestureRecognizers.Add (tgr);<br /></pre>  <h2>Triggers</h2> <a href="https://developer.xamarin.com/guides/xamarin-forms/working-with/triggers/">Triggers</a> provide similar functionality.  As opposed to general callback implementation, the Triggers functionality seems designed to implementing the fairly mundane UI transitions thats are caused by other UI events and state changes.  Since Button provides a Clicked event that’s raised in response to taps, we can setup a trigger on that and fire code in response: <pre><br />        &lt;Button x:Name="Button" Text="Button"&gt;<br />            &lt;Button.Triggers&gt;<br />                &lt;EventTrigger Event="Clicked"&gt;<br />                    &lt;local:TestTriggerAction /&gt;<br />                &lt;/EventTrigger&gt;<br />            &lt;/Button.Triggers&gt;<br />        &lt;/Button&gt;<br /><br />    public class TestTriggerAction : TriggerAction<View><br />    {<br />        protected override async void Invoke (View view)<br />        {<br />            await view.ScaleTo (1.1);<br />            await view.ScaleTo (1);<br />        }<br />    }<br /></pre>  The "working with triggers" document provides are fairly involved example of enabling/disabling a button based on the value of entry fields in the "Multi Triggers" section.  As well as playing some animations in "EnterActions and ExitActions".  <p/> Midway through writing this post I stumbled on the followup <a href="https://blog.xamarin.com/turn-events-into-commands-with-behaviors/">blog</a> from the author of "Simplifying Events".  It’s actually about turning events into behaviours, but it was the first time I’d seen how to create BindableProperty and I thought I could create a Trigger that has a Command and CommandParameter properties and reuse my Commands similar to:  <pre><br />    &lt;ListView.Triggers&gt;<br />        &lt;EventTrigger Event="ItemSelected"&gt;<br />            &lt;local:CommandTriggerAction Command="{Binding ItemSelectedCommand}" CommandParameter="{Binding Source={x:Reference items}, Path=SelectedItem}"/&gt;<br />        &lt;/EventTrigger&gt;<br />    &lt;/ListView.Triggers&gt;<br /></pre> Problem is to use BindableProperty the containing type needs to inherit from BindableObject (similar to Behaviour) but triggers need to inherit from TriggerAction.  Alas (thankfully?), C# doesn’t permit multiple-inheritance.  <h2>Conclusion</h2> Back to my original goal of UI windows dressing via data-driven animation. I need to separate the visual side effect from the functional one.  It felt like what I really need is the ability to define and process custom events/properties:  <pre><br />    public event EventHandler LoadingDone { add; remove; }<br /><br />    &lt;Button.Triggers&gt;<br />        &lt;EventTrigger Event=“LoadingDone"&gt;<br />            &lt;local:SomeTriggerAction /&gt;<br />        &lt;/EventTrigger&gt;<br />    &lt;/Button.Triggers&gt;<br /></pre> EventTrigger’s Event isn’t a BindableProperty, so even if you could bind to events you wouldn’t be able to rig it up.  DataTrigger does and it can be used to solve several problems.  While transitioning to Commands, one of the problems I frequently ran into was I initially had:  <pre><br />    &lt;Entry x:Name=“Username” Placeholder="Username"/&gt;<br />        &lt;Entry x:Name=“Password” Placeholder=“Password" IsPassword="true" /&gt;<br />    &lt;ActivityIndicator x:Name="BusyIndicator" IsRunning="false”&gt;<br />    &lt;Button Clicked=“onLogin” /&gt;<br /><br />        // In the code-behind<br />        async void onLogin(object sender, EventArgs args)<br />        {<br />            BusyIndicator.IsRunning = true;<br />            await App.Client.Login (Username.Text, Password.Text);<br />            BusyIndicator.IsRunning = false;<br />        }<br /></pre> I'm trying to do something in response to an event, and control the UI state at the same time.  But I didn't like the above approach because: <ol><li>Rather than my UI reacting to state changes in the ViewModel, I was driving the UI directly from code</li><li>I had to add code to the code-behind file (rather that separate ViewModel) because I needed to access the UI elements</li></ol>And I started to realise that excessive use of x:Name is an anti-pattern.  <p/> Instead, I created a state binding explicitly for this purpose: <pre><br />        &lt;Entry Placeholder="Username" /&gt;<br />        &lt;Entry Placeholder="Password" IsPassword="true" /&gt;<br /><br />        &lt;ActivityIndicator IsRunning="false"&gt;<br />            &lt;ActivityIndicator.Triggers&gt;<br />                &lt;DataTrigger TargetType="ActivityIndicator" Binding="{Binding IsBusy}" Value="true"&gt;<br />                    &lt;Setter Property="IsRunning" Value="true" /&gt;<br />                &lt;/DataTrigger&gt;<br />            &lt;/ActivityIndicator.Triggers&gt;<br />        &lt;/ActivityIndicator&gt;<br />        &lt;Button Text="Login" Command="{Binding LoginCommand}”&gt;<br /><br />        public string Username { get; set; }<br />        public string Password { get; set; }<br />        public ICommand LoginCommand { get; private set; }<br /><br />        public LoginViewModel()<br />        {<br />            LoginCommand = new Command (async (obj) => {<br />                IsBusy = true;<br />                await App.Client.Login (Username, Password);<br />                IsBusy = false;<br />            });    <br />        }<br /><br />        bool m_isBusy = false;<br />        public bool IsBusy {<br />            get {<br />                return m_isBusy;<br />            }<br />            set {<br />                if (value != m_isBusy) {<br />                    m_isBusy = value;<br />                    OnPropertyChanged ();<br />                }<br />            }<br />        }<br /></pre>