---
layout: post
title: Xamarin Forms part 3
date: '2016-03-27T16:48:00.004+09:00'
author: 'Contact:'
tags:
- xaml
- c#
- xamarin
- forms
- apps
modified_time: '2016-03-27T16:48:43.153+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-2293253341889057261
blogger_orig_url: https://www.blogger.com/comment.g?blogID=5371326417913853395&postID=2293253341889057261
---

Forms Intermediate  <<<< BEHAVIORS >>>> Behaviours (http://developer.xamarin.com/guides/xamarin-forms/working-with/behaviors/)   <<<< STYLES >>>>> Styles (https://developer.xamarin.com/guides/xamarin-forms/working-with/styles/ ) allow various settings to reused across elements: <ContentPage.Resources>        <ResourceDictionary><Style x:Key="EntryStyle" TargetType=“Entry">                <Setter Property="BackgroundColor" Value="Gray" />                <Style.Triggers>                    <EventTrigger Event="TextChanged">                        <local:ScaleTriggerAction  Length="200" />                    </EventTrigger>                </Style.Triggers>                <Style.Behaviors>                    <local:EntryBehavior />                </Style.Behaviors>            </Style>        </ResourceDictionary>    </ContentPage.Resources>   <Entry Style="{StaticResource EntryStyle}" />public class EntryBehavior : Behavior<Entry>    {         protected override void OnAttachedTo(Entry bo)         {             bo.TextChanged += (object sender, TextChangedEventArgs e) => ((Entry)sender).BackgroundColor = e.NewTextValue.Length == 0 ? Color.Red : Color.Green;             base.OnAttachedTo (bo);         }     }    While Triggers and Behaviours can be directly applied with a Style, GestureRecognizers can not.  However, GestureRecognizers can be applied with a Behaviour.  Recall the Tapped recogniser that passes a reference to the BoxView it’s attached to, this can be applied via a Style via a Behaviour: <ResourceDictionary>            <Style x:Key="DieStyle" TargetType="BoxView">                <Setter Property="Color" Value="Fuschia" />                <Style.Behaviors>                    <local:TappedBehavior />                </Style.Behaviors>            </Style>        </ResourceDictionary>public class TappedBehaviour : Behavior<BoxView>    {         protected override void OnAttachedTo(BoxView bo)         {             var tgr = new TapGestureRecognizer ();             tgr.SetBinding (TapGestureRecognizer.CommandProperty, "Tapped");             tgr.SetBinding (TapGestureRecognizer.CommandParameterProperty, bo);             bo.GestureRecognizers.Add (tgr);             base.OnAttachedTo (bo);         }     }    By setting TargetType to one of the parent types (e.g. VisualElement) a Style can be applied to a wider range of types.  However, you need to be careful that all types you apply it to provide the required properties, events, etc. (either directly or indirectly via Behaviours) otherwise you’ll get runtime exceptions.  <<<< MESSAGING >>> Another potential option lies in MessagingCenter (https://developer.xamarin.com/guides/xamarin-forms/messaging-center/).  While it seems like MessagingCenter can’t be used directly from XAML, you can obviously use it inside of Commands, TriggerActions and Behaviours.  This was my first solution for navigating from a command: public LoginPage ()         {             InitializeComponent ();             MessagingCenter.Subscribe<LoginViewModel> (this, "login", async (sender) => {                 Navigation.InsertPageBefore (new MainPage (), this);                 await Navigation.PopAsync ();             });         }  LoginCommand = new Command (async (obj) => {   <SNIP>                if (isSuccess) {                     MessagingCenter.Send<LoginViewModel>(this, "login");                 }             });   But it felt awkward tying the message to the view model.  At the moment I have: public class MessageCommand : Command // Unfortunately, Command<> is sealed     {         public class MsgProxy         {             public MsgProxy(string msg)             {                 MessagingCenter.Send<MsgProxy> (this, msg);             }         }          // MsgProxy is needed as you can't reference this in call to base()         public MessageCommand() : base( msg => new MsgProxy(msg as string))         {         }     } The command becomes: new MessageCommand.MsgProxy("login”); And in code-behind: MessagingCenter.Subscribe<MessageCommand.MsgProxy> (this, "login", async (sender) => {  // Whatever             });     Found this blog (http://blog.adamkemp.com/2014/09/navigation-with-mvvm_8.html)  describing another approach that’s fairly complex and involves interfaces and properties and reflection.  But feels like OO overkill to solve such a simple problem. 