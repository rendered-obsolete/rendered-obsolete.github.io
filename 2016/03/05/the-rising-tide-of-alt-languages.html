<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>The Rising Tide of Alt Languages | Rendered Obsolete</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="The Rising Tide of Alt Languages" />
<meta name="author" content="Contact:" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We’re in some kind of renaissance of programming languages. When I was first starting out I’d used a few languages (Basic, Pascal, C, a porpourri of assembly dialects), but the lack of Internet prevented me from knowing about all the miscellaneous toy “research” languages and I was only vaguely aware of Fortran/Cobol and so on. In Uni I was exposed to Java, VHDL, Scheme, Python, and a few more assembly dialects. &lt;p/&gt; But upon graduating, for years and years I regarded myself as a snooty, elitist c++ programmer. Besides occasional forays into Python or (eventually) c# for doing “scripting” or maybe making tools, I accepted that all real work was done with c++. Other languages were relegated to fooling around, teaching children, or “web programming”- and a select few (Perl) seemed to be specifically designed to torment people. After years of in-house engines, the horrors of UE3/CryEngine, etc. it took a few prototypes with Unity3D to make me see the errors of my ways. My university professors were correct; “software engineering” was about a lot more than banging out code and sweet macro shenanigans. &lt;p/&gt; More recently, JavaScript- which in my mind is still closely associated 90’s-era “mouseover” events- came back on the radar on account of the Node.js juggernaut. Only this time it wasn’t just for throw away web clients, it was for servers too. And, while I’ve still yet to look into it, I am aware that it is a thing. And a big one at that. &lt;p/&gt; As part of Microsoft’s increasingly virile affair with open source and multi-platform love-ins they released Visual Studio Code. After a bit of rummaging around, I was shocked to find out it too was made in JavaScript with a framework called Electron. Poking around their website uncovered a number of interesting platforms for developing apps/games like pixate, ionic, fireball, and superpowers. All of which I think of as the “next-generation” app/game development tools- similar to MaxPlay (which specifically mentions Electron in a Software Engineer job posting). &lt;p/&gt; I’ve been infatuated with F# for a while now. It had this sudden-outbreak-of-common-sense freshness about it: options, statically typed with powerful type inference, interoperability with c#, asynchronous computation expressions (monads), and other cornerstones of the functional world. But maybe I’d just grown tired of OO programming; it was getting a bit old and fat and FP was new hotness. Or, the old is new again, rather. Used it for a pair of backend prototypes but nothing in production. Somehow I can’t justify subjecting other people to the OCaml/ML universe just because it amuses me. &lt;p/&gt; For a while we were evaluating golang for constructing our new backend. Partially swept up by it’s apparently burgeoning popularity in China, we were specifically motivated by the experiences of Qihoo et al. I was also intrigued by the kind of performance numbers they were claiming (TODO: add disclaimer regarding benchmarks and contrived tests and real-world performance blah blah blah). I was pleased with their sensible approach to errors and how easy it was to get a working program, but more than a little disappointed with their insistence on flip-flopping between (IMHO) overly opinionated design decisions and embracing horrific mistakes like void* and the null. &lt;p/&gt; I’ve been spending some of my free time toying around with Rust. I’ve probably started reading The Book or futzed with Rust By Example 2 or 3 times now. But, I get busy or distracted and put it aside for a month or two such that I never really get it and am still sufficiently noob that I spend most of my time fighting with the compiler. Maybe it’s too strict… or maybe I need to stop trying to write c++ with it. &lt;p/&gt; While we’re on the topic of c++ “killers”, let’s not write out Java just yet. Despite my expectations that Oracle would succeed in smothering it, it’s instead staged a comeback and clawed itself to the top of the Tiobe index. It’s also being used (along with Akka) for the backend being developed in parallel by one of our other teams. &lt;p/&gt; As a final note, it’s difficult to bring up f#, golang, and rust without giving a shoutout to the numerous other languages that are often mentioned in the same breath: julia, kotlin, scala, nimrod, and numerous others. There really isn’t enough time in a day to investigate them all to a satisfactory level. &lt;p/&gt; Exciting stuff." />
<meta property="og:description" content="We’re in some kind of renaissance of programming languages. When I was first starting out I’d used a few languages (Basic, Pascal, C, a porpourri of assembly dialects), but the lack of Internet prevented me from knowing about all the miscellaneous toy “research” languages and I was only vaguely aware of Fortran/Cobol and so on. In Uni I was exposed to Java, VHDL, Scheme, Python, and a few more assembly dialects. &lt;p/&gt; But upon graduating, for years and years I regarded myself as a snooty, elitist c++ programmer. Besides occasional forays into Python or (eventually) c# for doing “scripting” or maybe making tools, I accepted that all real work was done with c++. Other languages were relegated to fooling around, teaching children, or “web programming”- and a select few (Perl) seemed to be specifically designed to torment people. After years of in-house engines, the horrors of UE3/CryEngine, etc. it took a few prototypes with Unity3D to make me see the errors of my ways. My university professors were correct; “software engineering” was about a lot more than banging out code and sweet macro shenanigans. &lt;p/&gt; More recently, JavaScript- which in my mind is still closely associated 90’s-era “mouseover” events- came back on the radar on account of the Node.js juggernaut. Only this time it wasn’t just for throw away web clients, it was for servers too. And, while I’ve still yet to look into it, I am aware that it is a thing. And a big one at that. &lt;p/&gt; As part of Microsoft’s increasingly virile affair with open source and multi-platform love-ins they released Visual Studio Code. After a bit of rummaging around, I was shocked to find out it too was made in JavaScript with a framework called Electron. Poking around their website uncovered a number of interesting platforms for developing apps/games like pixate, ionic, fireball, and superpowers. All of which I think of as the “next-generation” app/game development tools- similar to MaxPlay (which specifically mentions Electron in a Software Engineer job posting). &lt;p/&gt; I’ve been infatuated with F# for a while now. It had this sudden-outbreak-of-common-sense freshness about it: options, statically typed with powerful type inference, interoperability with c#, asynchronous computation expressions (monads), and other cornerstones of the functional world. But maybe I’d just grown tired of OO programming; it was getting a bit old and fat and FP was new hotness. Or, the old is new again, rather. Used it for a pair of backend prototypes but nothing in production. Somehow I can’t justify subjecting other people to the OCaml/ML universe just because it amuses me. &lt;p/&gt; For a while we were evaluating golang for constructing our new backend. Partially swept up by it’s apparently burgeoning popularity in China, we were specifically motivated by the experiences of Qihoo et al. I was also intrigued by the kind of performance numbers they were claiming (TODO: add disclaimer regarding benchmarks and contrived tests and real-world performance blah blah blah). I was pleased with their sensible approach to errors and how easy it was to get a working program, but more than a little disappointed with their insistence on flip-flopping between (IMHO) overly opinionated design decisions and embracing horrific mistakes like void* and the null. &lt;p/&gt; I’ve been spending some of my free time toying around with Rust. I’ve probably started reading The Book or futzed with Rust By Example 2 or 3 times now. But, I get busy or distracted and put it aside for a month or two such that I never really get it and am still sufficiently noob that I spend most of my time fighting with the compiler. Maybe it’s too strict… or maybe I need to stop trying to write c++ with it. &lt;p/&gt; While we’re on the topic of c++ “killers”, let’s not write out Java just yet. Despite my expectations that Oracle would succeed in smothering it, it’s instead staged a comeback and clawed itself to the top of the Tiobe index. It’s also being used (along with Akka) for the backend being developed in parallel by one of our other teams. &lt;p/&gt; As a final note, it’s difficult to bring up f#, golang, and rust without giving a shoutout to the numerous other languages that are often mentioned in the same breath: julia, kotlin, scala, nimrod, and numerous others. There really isn’t enough time in a day to investigate them all to a satisfactory level. &lt;p/&gt; Exciting stuff." />
<link rel="canonical" href="https://rendered-obsolete.bitbucket.io/2016/03/05/the-rising-tide-of-alt-languages.html" />
<meta property="og:url" content="https://rendered-obsolete.bitbucket.io/2016/03/05/the-rising-tide-of-alt-languages.html" />
<meta property="og:site_name" content="Rendered Obsolete" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-03-05T16:49:00+08:00" />
<script type="application/ld+json">
{"description":"We’re in some kind of renaissance of programming languages. When I was first starting out I’d used a few languages (Basic, Pascal, C, a porpourri of assembly dialects), but the lack of Internet prevented me from knowing about all the miscellaneous toy “research” languages and I was only vaguely aware of Fortran/Cobol and so on. In Uni I was exposed to Java, VHDL, Scheme, Python, and a few more assembly dialects. &lt;p/&gt; But upon graduating, for years and years I regarded myself as a snooty, elitist c++ programmer. Besides occasional forays into Python or (eventually) c# for doing “scripting” or maybe making tools, I accepted that all real work was done with c++. Other languages were relegated to fooling around, teaching children, or “web programming”- and a select few (Perl) seemed to be specifically designed to torment people. After years of in-house engines, the horrors of UE3/CryEngine, etc. it took a few prototypes with Unity3D to make me see the errors of my ways. My university professors were correct; “software engineering” was about a lot more than banging out code and sweet macro shenanigans. &lt;p/&gt; More recently, JavaScript- which in my mind is still closely associated 90’s-era “mouseover” events- came back on the radar on account of the Node.js juggernaut. Only this time it wasn’t just for throw away web clients, it was for servers too. And, while I’ve still yet to look into it, I am aware that it is a thing. And a big one at that. &lt;p/&gt; As part of Microsoft’s increasingly virile affair with open source and multi-platform love-ins they released Visual Studio Code. After a bit of rummaging around, I was shocked to find out it too was made in JavaScript with a framework called Electron. Poking around their website uncovered a number of interesting platforms for developing apps/games like pixate, ionic, fireball, and superpowers. All of which I think of as the “next-generation” app/game development tools- similar to MaxPlay (which specifically mentions Electron in a Software Engineer job posting). &lt;p/&gt; I’ve been infatuated with F# for a while now. It had this sudden-outbreak-of-common-sense freshness about it: options, statically typed with powerful type inference, interoperability with c#, asynchronous computation expressions (monads), and other cornerstones of the functional world. But maybe I’d just grown tired of OO programming; it was getting a bit old and fat and FP was new hotness. Or, the old is new again, rather. Used it for a pair of backend prototypes but nothing in production. Somehow I can’t justify subjecting other people to the OCaml/ML universe just because it amuses me. &lt;p/&gt; For a while we were evaluating golang for constructing our new backend. Partially swept up by it’s apparently burgeoning popularity in China, we were specifically motivated by the experiences of Qihoo et al. I was also intrigued by the kind of performance numbers they were claiming (TODO: add disclaimer regarding benchmarks and contrived tests and real-world performance blah blah blah). I was pleased with their sensible approach to errors and how easy it was to get a working program, but more than a little disappointed with their insistence on flip-flopping between (IMHO) overly opinionated design decisions and embracing horrific mistakes like void* and the null. &lt;p/&gt; I’ve been spending some of my free time toying around with Rust. I’ve probably started reading The Book or futzed with Rust By Example 2 or 3 times now. But, I get busy or distracted and put it aside for a month or two such that I never really get it and am still sufficiently noob that I spend most of my time fighting with the compiler. Maybe it’s too strict… or maybe I need to stop trying to write c++ with it. &lt;p/&gt; While we’re on the topic of c++ “killers”, let’s not write out Java just yet. Despite my expectations that Oracle would succeed in smothering it, it’s instead staged a comeback and clawed itself to the top of the Tiobe index. It’s also being used (along with Akka) for the backend being developed in parallel by one of our other teams. &lt;p/&gt; As a final note, it’s difficult to bring up f#, golang, and rust without giving a shoutout to the numerous other languages that are often mentioned in the same breath: julia, kotlin, scala, nimrod, and numerous others. There really isn’t enough time in a day to investigate them all to a satisfactory level. &lt;p/&gt; Exciting stuff.","author":{"@type":"Person","name":"Contact:"},"@type":"BlogPosting","url":"https://rendered-obsolete.bitbucket.io/2016/03/05/the-rising-tide-of-alt-languages.html","headline":"The Rising Tide of Alt Languages","dateModified":"2016-03-05T16:49:00+08:00","datePublished":"2016-03-05T16:49:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rendered-obsolete.bitbucket.io/2016/03/05/the-rising-tide-of-alt-languages.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="https://rendered-obsolete.bitbucket.io/feed.xml" title="Rendered Obsolete" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">Rendered Obsolete</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The Rising Tide of Alt Languages</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-03-05T16:49:00+08:00" itemprop="datePublished">
        
        Mar 5, 2016
      </time>
      
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Contact:</span></span>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    We're in some kind of renaissance of programming languages.  When I was first starting out I'd used a few languages (Basic, Pascal, C, a porpourri of assembly dialects), but the lack of Internet prevented me from knowing about all the miscellaneous toy "research" languages and I was only vaguely aware of Fortran/Cobol and so on.  In Uni I was exposed to Java, VHDL, Scheme, Python, and a few more assembly dialects.  <p/> But upon graduating, for years and years I regarded myself as a snooty, elitist c++ programmer.  Besides occasional forays into Python or (eventually) c# for doing "scripting" or maybe making tools, I accepted that all <em>real</em> work was done with c++.  Other languages were relegated to fooling around, teaching children, or "web programming"- and a select few (Perl) seemed to be specifically designed to torment people.  After years of in-house engines, the horrors of UE3/CryEngine, etc. it took a few prototypes with <a href="https://unity3d.com/">Unity3D</a> to make me see the errors of my ways.  My university professors were correct; "software engineering" was about a lot more than banging out code and sweet macro shenanigans.  <p/> More recently, JavaScript- which in my mind is still closely associated 90's-era "mouseover" events- came back on the radar on account of the <a href="https://nodejs.org">Node.js</a> juggernaut.  Only this time it wasn't just for throw away web clients, it was for servers too.  And, while I've still yet to look into it, I am aware that it is a <em>thing</em>.  And a big one at that.  <p/> As part of Microsoft's increasingly virile affair with open source and multi-platform love-ins they released <a href="https://code.visualstudio.com/">Visual Studio Code</a>.  After a bit of rummaging around, I was shocked to find out it too was made in JavaScript with a framework called <a href="http://electron.atom.io/">Electron</a>.  Poking around their website uncovered a number of interesting platforms for developing apps/games like <a href="http://www.pixate.com/">pixate</a>, <a href="http://ionic.io/">ionic</a>, <a href="http://fireball-x.com/en/">fireball</a>, and <a href="http://superpowers-html5.com/index.en.html">superpowers</a>.  All of which I think of as the "next-generation" app/game development tools- similar to <a href="http://www.maxplay.io/">MaxPlay</a> (which specifically mentions Electron in a <a href="http://maxplay.applytojob.com/apply/aOlOn0/Software-Engineer">Software Engineer job posting</a>).  <p/> I've been infatuated with <a href="http://fsharp.org/">F#</a> for a while now.  It had this sudden-outbreak-of-common-sense freshness about it: options, statically typed with powerful type inference, interoperability with c#, asynchronous computation expressions (monads), and other cornerstones of the functional world.  But maybe I'd just grown tired of OO programming; it was getting a bit old and fat and FP was new hotness.  Or, the old is new again, rather.  Used it for a pair of backend prototypes but nothing in production.  Somehow I can't justify subjecting other people to the OCaml/ML universe just because it amuses me.  <p/> For a while we were evaluating <a href="https://golang.org/">golang</a> for constructing our new backend.  Partially swept up by it's apparently burgeoning popularity in China, we were specifically motivated by the experiences of <a href="https://blog.golang.org/qihoo">Qihoo</a> et al.  I was also intrigued by the kind of <a href="http://benchmarksgame.alioth.debian.org/">performance numbers</a> they were claiming (TODO: add disclaimer regarding benchmarks and contrived tests and real-world performance blah blah blah).  I was pleased with their sensible approach to errors and how easy it was to get a working program, but more than a little disappointed with their insistence on flip-flopping between (IMHO) <a href="https://golang.org/doc/faq">overly opinionated design decisions</a> and embracing horrific mistakes like void* and <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">the</a> <a href="https://en.wikipedia.org/wiki/Tony_Hoare">null</a>.  <p/> I've been spending some of my free time toying around with <a href="https://www.rust-lang.org/">Rust</a>.  I've probably started reading <a href="https://doc.rust-lang.org/book/">The Book</a> or futzed with <a href="http://rustbyexample.com/">Rust By Example</a> 2 or 3 times now.  But, I get busy or distracted and put it aside for a month or two such that I never really <em>get it</em> and am still sufficiently noob that I spend most of my time fighting with the compiler.  Maybe it's too strict... or maybe I need to stop trying to write c++ with it.  <p/> While we're on the topic of c++ "killers", let's not write out Java just yet.  Despite my expectations that Oracle would succeed in smothering it, it's instead staged a comeback and clawed itself to the <a href="http://www.tiobe.com/tiobe_index">top of the Tiobe index</a>.  It's also being used (along with <a href="http://akka.io/">Akka</a>) for the backend being developed in parallel by one of our other teams.  <p/> As a final note, it's difficult to bring up f#, golang, and rust without giving a shoutout to the numerous other languages that are often mentioned in the same breath: <a href="http://julialang.org/">julia</a>, <a href="http://kotlinlang.org/">kotlin</a>, <a href="http://www.scala-lang.org/">scala</a>, <a href="http://nimrod-lang.org/">nimrod</a>, and numerous others.  There really isn't enough time in a day to investigate them all to a satisfactory level.  <p/> Exciting stuff.
  </div>

  

  <a class="u-url" href="/2016/03/05/the-rising-tide-of-alt-languages.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rendered Obsolete</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              Rendered Obsolete
            
            </li>
            
            <li><a class="u-email" href="mailto:renderedobsolete@gmail.com">renderedobsolete@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
