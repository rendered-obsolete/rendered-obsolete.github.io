<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Xamarin Forms part 1 | Rendered Obsolete</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="Xamarin Forms part 1" />
<meta name="author" content="Contact:" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This is the first part of my Xamarin Forms dive. &lt;h2&gt;Binding&lt;/h2&gt; Arguably the single most important thing to master as it connects your View (UI) to the ViewModel, it’s only fitting I start out with Binding (1, 2 and 3). Since I’ve been using Forms I’ve found that binding is key to getting things working but various nuances are scattered about in numerous demos. &lt;p/&gt; Bindings connect a “source” (either another UI element in the View or something in the ViewModel) to a “target” (some UI element in the View) that displays it. &lt;p/&gt; To start with, you’ll see that most projects create an XML namespace that refers to a .Net assembly generated by your project: &lt;pre&gt;&lt;!– “xmlns:local” ties “local” XML namespace to the “luck” C# namespace in the “luck” assembly –&gt;&lt;ContentPage xmlns=”http://xamarin.com/schemas/2014/forms” xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml” xmlns:local=”clr-namespace:luck;assembly=luck” x:Class=”luck.MainPage” &gt;&lt;/ContentPage&gt;// “local:MainViewModel” in XAML thus refers to a C# class similar to:namespace luck { public class MainViewModel { // Implementation }}&lt;/pre&gt; You can then easily create static bindings, references, and resources: &lt;pre&gt;&lt;!– Static –&gt;&lt;Label Text=”{x:Static local:MainViewModel.Text}” /&gt;// C# ViewModelpublic class MainViewModel { public static string Text = “text”;}&lt;!– Reference –&gt;&lt;Label Text=”text” x:Name=”MyText” /&gt;&lt;Label Text=”{x:Reference MyText}” /&gt;&lt;!– Resource –&gt; &lt;ContentPage.Resources&gt; &lt;ResourceDictionary&gt; &lt;local:LocalizationConverter x:Key=”LocalizationConverter” /&gt; &lt;/ResourceDictionary&gt; &lt;/ContentPage.Resources&gt; &lt;Label Text=”{Binding SelectedItem.DisplayName, Converter={StaticResource LocalizationConverter}}” /&gt;&lt;/pre&gt; There’s additional information about Resources and markup extensions here, and I’ll come back to ResourceDictionary a bit later in this series when I get to Styles. &lt;p/&gt; Alternatively, the Binding markup extension is the most common binding technique and more advanced as it supports several different properties. The easiest way of specifying a source is by setting the BindingContext for the entire Page since it is inherited by all children. This can be done either in your code-behind constructor: &lt;pre&gt;public MainPage (){ InitializeComponent (); BindingContext = new MainViewModel (); }&lt;/pre&gt; or via XAML: &lt;pre&gt; &lt;ContentPage.BindingContext&gt; &lt;local:MainViewModel /&gt; &lt;/ContentPage.BindingContext&gt;&lt;/pre&gt; You can then bind a simple value: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;public class MainViewModel { public string Text { get; set; }}&lt;/pre&gt; As already mentioned, Binding supports several different properties. Path specifies the property of the source to which we are binding and can be omitted if it’s the first property. The following two are equivalent: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;&lt;Label Text=”{Binding Path=Text}” /&gt;&lt;/pre&gt; The Path property is able to access sub-properties as well as the index operator. For example: &lt;pre&gt;&lt;Label Text=”{Binding Values.Count}” /&gt;&lt;Label Text=”{Binding Values[key]}” /&gt;// In the ViewModelpublic Dictionary&lt;string, string&gt; Values { get; set; }&lt;/pre&gt; According to this, if you have large numbers of values to set you can simplify multiple indexed bindings by setting the binding context: &lt;pre&gt;&lt;StackLayout BindingContext=”{Binding Values}” /&gt; &lt;Label Text=”{Binding [key]}” /&gt;&lt;StackLayout /&gt;&lt;/pre&gt; There is also a shorthand syntax to bind directly to the BindingContext itself: &lt;pre&gt;&lt;Label Text=”{Binding .}” /&gt;&lt;/pre&gt; The Source property allows the binding to explicitly specify the “source” of a binding. It’s analogous to the BindingContext (where the target specifies the source) and the following are equivalent: &lt;pre&gt;&lt;Label BindingContext=”{x:Reference items}” Text=”{Binding SelectedItem, StringFormat=’{0}’}” /&gt;&lt;Label Text=”{Binding SelectedItem, Source={x:Reference items}, StringFormat=’{0}’}” /&gt;&lt;/pre&gt; The biggest difference being using BindingContext will be inherited by all sub-children of the UI element. At one point I found myself repeatedly specifying BindingContext and Source for a number of nested elements and then running into problems where I could no longer reference the original BindingContext, etc. In this case I had to carefully consider what I was binding where and reorganise the data provided by my ViewModel to cut back on the excessive use of Source. &lt;p/&gt; StringFormat can be used to apply string conversion and formatting: &lt;pre&gt;&lt;Label Text=”{Binding Value, StringFormat=’Formatted {0}’}” /&gt;&lt;/pre&gt; Internally it uses String.Format method so it accepts all the same forms. Note that because both .Net formatting and markup extensions use curly braces, StringFormat must be enclosed in single quotes. &lt;p/&gt; The Converter property is more generalised than StringFormat and also accepts an optional ConverterParameter value: &lt;pre&gt; &lt;Label Text=”{Binding SomeInt, Converter={StaticResource IntConverter}, ConverterParameter=10}” /&gt; public class IntConverter : IValueConverter { public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return (int)value * intparam; } public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return ((int)value) / intparam; } }&lt;/pre&gt; Mode The final property Mode is available to solve some specific binding problems. I’ve not done anything with it just yet, so I’ll refer to two relevant documents from Xamarin (1, 2) and revisit it later when I understand it better. &lt;h2&gt;Dynamic Bindings&lt;/h2&gt; For values that can be changed at runtime, either the property you’re binding to or the entire ViewModel needs to implement INotifyPropertyChanged interface. For example, using System.Collections.ObjectModel.ObservableCollection: &lt;pre&gt;public static ObservableCollection Chats = new ObservableCollection();&lt;/pre&gt; You can even define your own: &lt;pre&gt; public class ObservableString : System.ComponentModel.INotifyPropertyChanged { public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged; string val; public string Value { get { return val; } set { val = value; OnPropertyChanged (&quot;Value&quot;); } } void OnPropertyChanged(string propertyName = null) { if (PropertyChanged != null) PropertyChanged (this, new System.ComponentModel.PropertyChangedEventArgs (propertyName)); } }&lt;/pre&gt; But this only seems to work with static bindings. The more standard approach is to implement INotifyPropertyChanged for your entire ViewModel: &lt;pre&gt; public class LoginViewModel : INotifyPropertyChanged { bool m_isBusy = false; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (&quot;IsBusy&quot;); } } } #region INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged (string propertyName) { var changed = PropertyChanged; if (changed != null) { PropertyChanged (this, new PropertyChangedEventArgs (propertyName)); } } #endregion }&lt;/pre&gt; With .Net 4.5 OnPropertyChanged can be simplified: &lt;pre&gt; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (); } } } protected virtual void OnPropertyChanged ([System.Runtime.CompilerServices.CallerMemberName] string propertyName = &quot;&quot;) { /* same as above */ }&lt;/pre&gt; A minor improvement, but now the compiler guarantees that the property name always matches the &quot;magic string&quot;. There’s further improvements to reduce all the boilerplate needed to implement properties (specifically this, and more generally like this and this). &lt;p/&gt; This ran a bit long, but it should wrap up the first dump of my notes on Xamarin Forms. Next up: Callbacks, Commands, and Triggers... oh my!" />
<meta property="og:description" content="This is the first part of my Xamarin Forms dive. &lt;h2&gt;Binding&lt;/h2&gt; Arguably the single most important thing to master as it connects your View (UI) to the ViewModel, it’s only fitting I start out with Binding (1, 2 and 3). Since I’ve been using Forms I’ve found that binding is key to getting things working but various nuances are scattered about in numerous demos. &lt;p/&gt; Bindings connect a “source” (either another UI element in the View or something in the ViewModel) to a “target” (some UI element in the View) that displays it. &lt;p/&gt; To start with, you’ll see that most projects create an XML namespace that refers to a .Net assembly generated by your project: &lt;pre&gt;&lt;!– “xmlns:local” ties “local” XML namespace to the “luck” C# namespace in the “luck” assembly –&gt;&lt;ContentPage xmlns=”http://xamarin.com/schemas/2014/forms” xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml” xmlns:local=”clr-namespace:luck;assembly=luck” x:Class=”luck.MainPage” &gt;&lt;/ContentPage&gt;// “local:MainViewModel” in XAML thus refers to a C# class similar to:namespace luck { public class MainViewModel { // Implementation }}&lt;/pre&gt; You can then easily create static bindings, references, and resources: &lt;pre&gt;&lt;!– Static –&gt;&lt;Label Text=”{x:Static local:MainViewModel.Text}” /&gt;// C# ViewModelpublic class MainViewModel { public static string Text = “text”;}&lt;!– Reference –&gt;&lt;Label Text=”text” x:Name=”MyText” /&gt;&lt;Label Text=”{x:Reference MyText}” /&gt;&lt;!– Resource –&gt; &lt;ContentPage.Resources&gt; &lt;ResourceDictionary&gt; &lt;local:LocalizationConverter x:Key=”LocalizationConverter” /&gt; &lt;/ResourceDictionary&gt; &lt;/ContentPage.Resources&gt; &lt;Label Text=”{Binding SelectedItem.DisplayName, Converter={StaticResource LocalizationConverter}}” /&gt;&lt;/pre&gt; There’s additional information about Resources and markup extensions here, and I’ll come back to ResourceDictionary a bit later in this series when I get to Styles. &lt;p/&gt; Alternatively, the Binding markup extension is the most common binding technique and more advanced as it supports several different properties. The easiest way of specifying a source is by setting the BindingContext for the entire Page since it is inherited by all children. This can be done either in your code-behind constructor: &lt;pre&gt;public MainPage (){ InitializeComponent (); BindingContext = new MainViewModel (); }&lt;/pre&gt; or via XAML: &lt;pre&gt; &lt;ContentPage.BindingContext&gt; &lt;local:MainViewModel /&gt; &lt;/ContentPage.BindingContext&gt;&lt;/pre&gt; You can then bind a simple value: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;public class MainViewModel { public string Text { get; set; }}&lt;/pre&gt; As already mentioned, Binding supports several different properties. Path specifies the property of the source to which we are binding and can be omitted if it’s the first property. The following two are equivalent: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;&lt;Label Text=”{Binding Path=Text}” /&gt;&lt;/pre&gt; The Path property is able to access sub-properties as well as the index operator. For example: &lt;pre&gt;&lt;Label Text=”{Binding Values.Count}” /&gt;&lt;Label Text=”{Binding Values[key]}” /&gt;// In the ViewModelpublic Dictionary&lt;string, string&gt; Values { get; set; }&lt;/pre&gt; According to this, if you have large numbers of values to set you can simplify multiple indexed bindings by setting the binding context: &lt;pre&gt;&lt;StackLayout BindingContext=”{Binding Values}” /&gt; &lt;Label Text=”{Binding [key]}” /&gt;&lt;StackLayout /&gt;&lt;/pre&gt; There is also a shorthand syntax to bind directly to the BindingContext itself: &lt;pre&gt;&lt;Label Text=”{Binding .}” /&gt;&lt;/pre&gt; The Source property allows the binding to explicitly specify the “source” of a binding. It’s analogous to the BindingContext (where the target specifies the source) and the following are equivalent: &lt;pre&gt;&lt;Label BindingContext=”{x:Reference items}” Text=”{Binding SelectedItem, StringFormat=’{0}’}” /&gt;&lt;Label Text=”{Binding SelectedItem, Source={x:Reference items}, StringFormat=’{0}’}” /&gt;&lt;/pre&gt; The biggest difference being using BindingContext will be inherited by all sub-children of the UI element. At one point I found myself repeatedly specifying BindingContext and Source for a number of nested elements and then running into problems where I could no longer reference the original BindingContext, etc. In this case I had to carefully consider what I was binding where and reorganise the data provided by my ViewModel to cut back on the excessive use of Source. &lt;p/&gt; StringFormat can be used to apply string conversion and formatting: &lt;pre&gt;&lt;Label Text=”{Binding Value, StringFormat=’Formatted {0}’}” /&gt;&lt;/pre&gt; Internally it uses String.Format method so it accepts all the same forms. Note that because both .Net formatting and markup extensions use curly braces, StringFormat must be enclosed in single quotes. &lt;p/&gt; The Converter property is more generalised than StringFormat and also accepts an optional ConverterParameter value: &lt;pre&gt; &lt;Label Text=”{Binding SomeInt, Converter={StaticResource IntConverter}, ConverterParameter=10}” /&gt; public class IntConverter : IValueConverter { public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return (int)value * intparam; } public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return ((int)value) / intparam; } }&lt;/pre&gt; Mode The final property Mode is available to solve some specific binding problems. I’ve not done anything with it just yet, so I’ll refer to two relevant documents from Xamarin (1, 2) and revisit it later when I understand it better. &lt;h2&gt;Dynamic Bindings&lt;/h2&gt; For values that can be changed at runtime, either the property you’re binding to or the entire ViewModel needs to implement INotifyPropertyChanged interface. For example, using System.Collections.ObjectModel.ObservableCollection: &lt;pre&gt;public static ObservableCollection Chats = new ObservableCollection();&lt;/pre&gt; You can even define your own: &lt;pre&gt; public class ObservableString : System.ComponentModel.INotifyPropertyChanged { public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged; string val; public string Value { get { return val; } set { val = value; OnPropertyChanged (&quot;Value&quot;); } } void OnPropertyChanged(string propertyName = null) { if (PropertyChanged != null) PropertyChanged (this, new System.ComponentModel.PropertyChangedEventArgs (propertyName)); } }&lt;/pre&gt; But this only seems to work with static bindings. The more standard approach is to implement INotifyPropertyChanged for your entire ViewModel: &lt;pre&gt; public class LoginViewModel : INotifyPropertyChanged { bool m_isBusy = false; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (&quot;IsBusy&quot;); } } } #region INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged (string propertyName) { var changed = PropertyChanged; if (changed != null) { PropertyChanged (this, new PropertyChangedEventArgs (propertyName)); } } #endregion }&lt;/pre&gt; With .Net 4.5 OnPropertyChanged can be simplified: &lt;pre&gt; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (); } } } protected virtual void OnPropertyChanged ([System.Runtime.CompilerServices.CallerMemberName] string propertyName = &quot;&quot;) { /* same as above */ }&lt;/pre&gt; A minor improvement, but now the compiler guarantees that the property name always matches the &quot;magic string&quot;. There’s further improvements to reduce all the boilerplate needed to implement properties (specifically this, and more generally like this and this). &lt;p/&gt; This ran a bit long, but it should wrap up the first dump of my notes on Xamarin Forms. Next up: Callbacks, Commands, and Triggers... oh my!" />
<link rel="canonical" href="http://localhost:4000/2016/04/05/xamarin-forms-part-1.html" />
<meta property="og:url" content="http://localhost:4000/2016/04/05/xamarin-forms-part-1.html" />
<meta property="og:site_name" content="Rendered Obsolete" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2016-04-05T18:20:00+08:00" />
<script type="application/ld+json">
{"description":"This is the first part of my Xamarin Forms dive. &lt;h2&gt;Binding&lt;/h2&gt; Arguably the single most important thing to master as it connects your View (UI) to the ViewModel, it’s only fitting I start out with Binding (1, 2 and 3). Since I’ve been using Forms I’ve found that binding is key to getting things working but various nuances are scattered about in numerous demos. &lt;p/&gt; Bindings connect a “source” (either another UI element in the View or something in the ViewModel) to a “target” (some UI element in the View) that displays it. &lt;p/&gt; To start with, you’ll see that most projects create an XML namespace that refers to a .Net assembly generated by your project: &lt;pre&gt;&lt;!– “xmlns:local” ties “local” XML namespace to the “luck” C# namespace in the “luck” assembly –&gt;&lt;ContentPage xmlns=”http://xamarin.com/schemas/2014/forms” xmlns:x=”http://schemas.microsoft.com/winfx/2009/xaml” xmlns:local=”clr-namespace:luck;assembly=luck” x:Class=”luck.MainPage” &gt;&lt;/ContentPage&gt;// “local:MainViewModel” in XAML thus refers to a C# class similar to:namespace luck { public class MainViewModel { // Implementation }}&lt;/pre&gt; You can then easily create static bindings, references, and resources: &lt;pre&gt;&lt;!– Static –&gt;&lt;Label Text=”{x:Static local:MainViewModel.Text}” /&gt;// C# ViewModelpublic class MainViewModel { public static string Text = “text”;}&lt;!– Reference –&gt;&lt;Label Text=”text” x:Name=”MyText” /&gt;&lt;Label Text=”{x:Reference MyText}” /&gt;&lt;!– Resource –&gt; &lt;ContentPage.Resources&gt; &lt;ResourceDictionary&gt; &lt;local:LocalizationConverter x:Key=”LocalizationConverter” /&gt; &lt;/ResourceDictionary&gt; &lt;/ContentPage.Resources&gt; &lt;Label Text=”{Binding SelectedItem.DisplayName, Converter={StaticResource LocalizationConverter}}” /&gt;&lt;/pre&gt; There’s additional information about Resources and markup extensions here, and I’ll come back to ResourceDictionary a bit later in this series when I get to Styles. &lt;p/&gt; Alternatively, the Binding markup extension is the most common binding technique and more advanced as it supports several different properties. The easiest way of specifying a source is by setting the BindingContext for the entire Page since it is inherited by all children. This can be done either in your code-behind constructor: &lt;pre&gt;public MainPage (){ InitializeComponent (); BindingContext = new MainViewModel (); }&lt;/pre&gt; or via XAML: &lt;pre&gt; &lt;ContentPage.BindingContext&gt; &lt;local:MainViewModel /&gt; &lt;/ContentPage.BindingContext&gt;&lt;/pre&gt; You can then bind a simple value: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;public class MainViewModel { public string Text { get; set; }}&lt;/pre&gt; As already mentioned, Binding supports several different properties. Path specifies the property of the source to which we are binding and can be omitted if it’s the first property. The following two are equivalent: &lt;pre&gt;&lt;Label Text=”{Binding Text}” /&gt;&lt;Label Text=”{Binding Path=Text}” /&gt;&lt;/pre&gt; The Path property is able to access sub-properties as well as the index operator. For example: &lt;pre&gt;&lt;Label Text=”{Binding Values.Count}” /&gt;&lt;Label Text=”{Binding Values[key]}” /&gt;// In the ViewModelpublic Dictionary&lt;string, string&gt; Values { get; set; }&lt;/pre&gt; According to this, if you have large numbers of values to set you can simplify multiple indexed bindings by setting the binding context: &lt;pre&gt;&lt;StackLayout BindingContext=”{Binding Values}” /&gt; &lt;Label Text=”{Binding [key]}” /&gt;&lt;StackLayout /&gt;&lt;/pre&gt; There is also a shorthand syntax to bind directly to the BindingContext itself: &lt;pre&gt;&lt;Label Text=”{Binding .}” /&gt;&lt;/pre&gt; The Source property allows the binding to explicitly specify the “source” of a binding. It’s analogous to the BindingContext (where the target specifies the source) and the following are equivalent: &lt;pre&gt;&lt;Label BindingContext=”{x:Reference items}” Text=”{Binding SelectedItem, StringFormat=’{0}’}” /&gt;&lt;Label Text=”{Binding SelectedItem, Source={x:Reference items}, StringFormat=’{0}’}” /&gt;&lt;/pre&gt; The biggest difference being using BindingContext will be inherited by all sub-children of the UI element. At one point I found myself repeatedly specifying BindingContext and Source for a number of nested elements and then running into problems where I could no longer reference the original BindingContext, etc. In this case I had to carefully consider what I was binding where and reorganise the data provided by my ViewModel to cut back on the excessive use of Source. &lt;p/&gt; StringFormat can be used to apply string conversion and formatting: &lt;pre&gt;&lt;Label Text=”{Binding Value, StringFormat=’Formatted {0}’}” /&gt;&lt;/pre&gt; Internally it uses String.Format method so it accepts all the same forms. Note that because both .Net formatting and markup extensions use curly braces, StringFormat must be enclosed in single quotes. &lt;p/&gt; The Converter property is more generalised than StringFormat and also accepts an optional ConverterParameter value: &lt;pre&gt; &lt;Label Text=”{Binding SomeInt, Converter={StaticResource IntConverter}, ConverterParameter=10}” /&gt; public class IntConverter : IValueConverter { public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return (int)value * intparam; } public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture) { int intparam; if (!int.TryParse(parameter as string, out intparam)) intparam = 1; return ((int)value) / intparam; } }&lt;/pre&gt; Mode The final property Mode is available to solve some specific binding problems. I’ve not done anything with it just yet, so I’ll refer to two relevant documents from Xamarin (1, 2) and revisit it later when I understand it better. &lt;h2&gt;Dynamic Bindings&lt;/h2&gt; For values that can be changed at runtime, either the property you’re binding to or the entire ViewModel needs to implement INotifyPropertyChanged interface. For example, using System.Collections.ObjectModel.ObservableCollection: &lt;pre&gt;public static ObservableCollection Chats = new ObservableCollection();&lt;/pre&gt; You can even define your own: &lt;pre&gt; public class ObservableString : System.ComponentModel.INotifyPropertyChanged { public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged; string val; public string Value { get { return val; } set { val = value; OnPropertyChanged (&quot;Value&quot;); } } void OnPropertyChanged(string propertyName = null) { if (PropertyChanged != null) PropertyChanged (this, new System.ComponentModel.PropertyChangedEventArgs (propertyName)); } }&lt;/pre&gt; But this only seems to work with static bindings. The more standard approach is to implement INotifyPropertyChanged for your entire ViewModel: &lt;pre&gt; public class LoginViewModel : INotifyPropertyChanged { bool m_isBusy = false; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (&quot;IsBusy&quot;); } } } #region INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged; protected virtual void OnPropertyChanged (string propertyName) { var changed = PropertyChanged; if (changed != null) { PropertyChanged (this, new PropertyChangedEventArgs (propertyName)); } } #endregion }&lt;/pre&gt; With .Net 4.5 OnPropertyChanged can be simplified: &lt;pre&gt; public bool IsBusy { get { return m_isBusy; } set { if (value != m_isBusy) { m_isBusy = value; OnPropertyChanged (); } } } protected virtual void OnPropertyChanged ([System.Runtime.CompilerServices.CallerMemberName] string propertyName = &quot;&quot;) { /* same as above */ }&lt;/pre&gt; A minor improvement, but now the compiler guarantees that the property name always matches the &quot;magic string&quot;. There’s further improvements to reduce all the boilerplate needed to implement properties (specifically this, and more generally like this and this). &lt;p/&gt; This ran a bit long, but it should wrap up the first dump of my notes on Xamarin Forms. Next up: Callbacks, Commands, and Triggers... oh my!","author":{"@type":"Person","name":"Contact:"},"@type":"BlogPosting","url":"http://localhost:4000/2016/04/05/xamarin-forms-part-1.html","headline":"Xamarin Forms part 1","dateModified":"2016-04-05T18:20:00+08:00","datePublished":"2016-04-05T18:20:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2016/04/05/xamarin-forms-part-1.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Rendered Obsolete" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">Rendered Obsolete</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Xamarin Forms part 1</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-04-05T18:20:00+08:00" itemprop="datePublished">
        
        Apr 5, 2016
      </time>
      
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Contact:</span></span>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    This is the first part of my Xamarin Forms dive.  <h2>Binding</h2> Arguably the single most important thing to master as it connects your View (UI) to the ViewModel, it's only fitting I start out with Binding (<a href="https://developer.xamarin.com/guides/xamarin-forms/getting-started/introduction-to-xamarin-forms/#Data_Binding">1</a>, <a href="https://blog.xamarin.com/introduction-to-data-binding/">2</a>  and <a href="https://blog.xamarin.com/advanced-data-binding-for-ios-android-and-windows/">3</a>).  Since I’ve been using Forms I’ve found that binding is key to getting things working but various nuances are scattered about in numerous demos.  <p/> Bindings connect a "source" (either another UI element in the View or something in the ViewModel) to a "target" (some UI element in the View) that displays it.  <p/> To start with, you'll see that most projects create an XML namespace that refers to a .Net assembly generated by your project:  <pre><br />&lt;!-- "xmlns:local" ties "local" XML namespace to the "luck" C# namespace in the "luck" assembly --&gt;<br />&lt;ContentPage<br />    xmlns="http://xamarin.com/schemas/2014/forms"<br />    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"<br />    xmlns:local="clr-namespace:luck;assembly=luck"<br />    x:Class="luck.MainPage"<br />    &gt;<br />&lt;/ContentPage&gt;<br /><br />// "local:MainViewModel" in XAML thus refers to a C# class similar to:<br />namespace luck {<br />    public class MainViewModel {<br />        // Implementation<br />    }<br />}<br /></pre> You can then easily create static bindings, references, and resources:  <pre><br />&lt;!-- Static --&gt;<br />&lt;Label Text="{x:Static local:MainViewModel.Text}" /&gt;<br /><br />// C# ViewModel<br />public class MainViewModel {<br />    public static string Text = "text";<br />}<br /><br />&lt;!-- Reference --&gt;<br />&lt;Label Text="text" x:Name="MyText" /&gt;<br />&lt;Label Text="{x:Reference MyText}" /&gt;<br /><br />&lt;!-- Resource --&gt;<br />    &lt;ContentPage.Resources&gt;<br />        &lt;ResourceDictionary&gt;<br />            &lt;local:LocalizationConverter<br />                x:Key="LocalizationConverter" /&gt;<br />        &lt;/ResourceDictionary&gt;<br />    &lt;/ContentPage.Resources&gt;<br />    &lt;Label Text="{Binding SelectedItem.DisplayName,<br />        Converter={StaticResource LocalizationConverter}}" /&gt;<br /></pre> There's additional information about Resources and markup extensions <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/xaml_markup_extensions/">here</a>, and I'll come back to ResourceDictionary a bit later in this series when I get to Styles.  <p/> Alternatively, the Binding markup extension is the most common binding technique and more advanced as it supports several different properties.  The easiest way of specifying a source is by setting the BindingContext for the entire Page since it is inherited by all children.  This can be done either in your code-behind constructor:  <pre><br />public MainPage ()<br />{<br />     InitializeComponent ();<br />     BindingContext = new MainViewModel (); <br />}<br /></pre> or via XAML:  <pre><br />    &lt;ContentPage.BindingContext&gt;<br />        &lt;local:MainViewModel /&gt;<br />    &lt;/ContentPage.BindingContext&gt;<br /></pre> You can then bind a simple value:  <pre><br />&lt;Label Text="{Binding Text}" /&gt;<br /><br />public class MainViewModel {<br />    public string Text { get; set; }<br />}<br /></pre> As already mentioned, Binding supports several different properties.  <em>Path</em> specifies the property of the source to which we are binding and can be omitted if it's the first property.  The following two are equivalent: <pre><br />&lt;Label Text="{Binding Text}" /&gt;<br />&lt;Label Text="{Binding Path=Text}" /&gt;<br /></pre> The Path property is able to access sub-properties as well as the index operator.  For example: <pre><br />&lt;Label Text="{Binding Values.Count}" /&gt;<br />&lt;Label Text="{Binding Values[key]}" /&gt;<br /><br />// In the ViewModel<br />public Dictionary<string, string> Values { get; set; }<br /></pre> According to <a href="http://forums.xamarin.com/discussion/19361/data-binding-to-dictionary-object">this</a>, if you have large numbers of values to set you can simplify multiple indexed bindings by setting the binding context: <pre><br />&lt;StackLayout BindingContext="{Binding Values}" /&gt;<br />    &lt;Label Text="{Binding [key]}" /&gt;<br />&lt;StackLayout /&gt;<br /></pre> There is also a shorthand syntax to bind directly to the BindingContext itself: <pre><br />&lt;Label Text="{Binding .}" /&gt;<br /></pre> The <em>Source</em> property allows the binding to explicitly specify the "source" of a binding.  It's analogous to the BindingContext (where the target specifies the source) and the following are equivalent:  <pre><br />&lt;Label BindingContext="{x:Reference items}" Text="{Binding SelectedItem, StringFormat='{0}'}" /&gt;<br />&lt;Label Text="{Binding SelectedItem, Source={x:Reference items}, StringFormat='{0}'}" /&gt;<br /></pre> The biggest difference being using BindingContext will be inherited by all sub-children of the UI element.  At one point I found myself repeatedly specifying BindingContext and Source for a number of nested elements and then running into problems where I could no longer reference the original BindingContext, etc.  In this case I had to carefully consider what I was binding where and reorganise the data provided by my ViewModel to cut back on the excessive use of Source.  <p/> <em>StringFormat</em> can be used to apply string conversion and formatting: <pre><br />&lt;Label Text="{Binding Value, StringFormat='Formatted {0}'}" /&gt;<br /></pre> Internally it uses <a href="https://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx">String.Format</a> method so it accepts all the same forms.  Note that because both .Net formatting and markup extensions use curly braces, StringFormat must be enclosed in single quotes.  <p/> The <em>Converter</em> property is more generalised than StringFormat and also accepts an optional <em>ConverterParameter</em> value: <pre><br /> &lt;Label Text="{Binding SomeInt, Converter={StaticResource IntConverter}, ConverterParameter=10}" /&gt;<br /><br /> public class IntConverter : IValueConverter<br /> {<br />  public object Convert(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)<br />  {<br />   int intparam;<br />   if (!int.TryParse(parameter as string, out intparam))<br />    intparam = 1;<br /><br />   return (int)value * intparam;<br />  }<br /><br />  public object ConvertBack(object value, System.Type targetType, object parameter, System.Globalization.CultureInfo culture)<br />  {<br />   int intparam;<br />   if (!int.TryParse(parameter as string, out intparam))<br />    intparam = 1;<br /><br />   return ((int)value) / intparam;<br />  }<br /> }<br /></pre> <em>Mode</em> The final property <em>Mode</em> is available to solve some specific binding problems.  I've not done anything with it just yet, so I'll refer to two relevant documents from Xamarin (<a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/data_binding_basics/">1</a>, <a href="https://developer.xamarin.com/guides/xamarin-forms/user-interface/xaml-basics/data_bindings_to_mvvm/">2</a>) and revisit it later when I understand it better.  <h2>Dynamic Bindings</h2> For values that can be changed at runtime, either the property you're binding to or the entire ViewModel needs to implement INotifyPropertyChanged interface.  For example, using System.Collections.ObjectModel.ObservableCollection: <pre><br />public static ObservableCollection<Chat> Chats = new ObservableCollection<Chat>();<br /><br /><ListView ItemsSource="{x:Static local:ChatsViewModel.Chats}" x:Name="Chats" ItemSelected="onItemSelected"><br /></pre> You can even define your own: <pre><br />    public class ObservableString : System.ComponentModel.INotifyPropertyChanged<br />    {<br />        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;<br /><br />        string val;<br />        public string Value<br />        {<br />            get { return val; }<br />            set {<br />                val = value;<br />                OnPropertyChanged ("Value");<br />            }<br />        }<br /><br />        void OnPropertyChanged(string propertyName = null)<br />        {<br />            if (PropertyChanged != null)<br />                PropertyChanged (this, new System.ComponentModel.PropertyChangedEventArgs (propertyName));<br />        }<br />    }<br /></pre> But this only seems to work with static bindings.  The more standard approach is to implement INotifyPropertyChanged for your entire ViewModel:  <pre><br />    public class LoginViewModel : INotifyPropertyChanged<br />    {<br />        bool m_isBusy = false;<br />        public bool IsBusy {<br />            get {<br />                return m_isBusy;<br />            }<br />            set {<br />                if (value != m_isBusy) {<br />                    m_isBusy = value;<br />                    OnPropertyChanged ("IsBusy");<br />                }<br />            }<br />        }<br /><br />        #region INotifyPropertyChanged<br /><br />        public event PropertyChangedEventHandler PropertyChanged;<br /><br />        protected virtual void OnPropertyChanged (string propertyName)<br />        {<br />            var changed = PropertyChanged;<br />            if (changed != null) {<br />                PropertyChanged (this, new PropertyChangedEventArgs (propertyName));<br />            }<br />        }<br />        #endregion<br />    }<br /></pre> With .Net 4.5 OnPropertyChanged can be simplified: <pre><br />        public bool IsBusy {<br />            get {<br />                return m_isBusy;<br />            }<br />            set {<br />                if (value != m_isBusy) {<br />                    m_isBusy = value;<br />                    OnPropertyChanged ();<br />                }<br />            }<br />        }<br /><br />        protected virtual void OnPropertyChanged ([System.Runtime.CompilerServices.CallerMemberName] string propertyName = "")<br />        { /* same as above */ }<br /></pre> A minor improvement, but now the compiler guarantees that the property name always matches the "magic string".  There’s further improvements to reduce all the boilerplate needed to implement properties (specifically <a href="http://danrigby.com/2012/01/08/inotifypropertychanged-the-anders-hejlsberg-way/">this</a>, and more generally like <a href="https://msdn.microsoft.com/en-us/library/bb126445.aspx">this</a> and <a href="https://www.postsharp.net/">this</a>).  <p/> This ran a bit long, but it should wrap up the first dump of my notes on Xamarin Forms.  Next up: Callbacks, Commands, and Triggers... oh my!
  </div>

  

  <a class="u-url" href="/2016/04/05/xamarin-forms-part-1.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rendered Obsolete</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              Rendered Obsolete
            
            </li>
            
            <li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
