<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>AA-sort | Rendered Obsolete</title>
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="AA-sort" />
<meta name="author" content="Contact:" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A co-worker sent me a link to AA-sort some time ago, but I didn’t have any reason to use it until just recently. I found myself in a situation where I have 2K~4K 4-byte elements packet into qwords and my initial O(N^2) solution just wasn’t working out. So, I decided to try the O(N log N) “in-core” component of AA-sort as a pre-sort.&lt;div&gt;&lt;/div&gt;&lt;div&gt;The paper linked above is relatively straight-forward, but they only provide pseudo-code so there’s still a bit of effort required to get something usable. As per the author’s goals, it’s easily written as highly-vectorized, non-branching code and was rather fun to get working.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;The authors were working with 8 16-bit values packed into a qword, and I had to make some simple changes to get it working with vec_uint4s.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;First, my bitonic_sort() routine takes care of step one of their in-core algorithm by sorting the 4 uint32t elements in a qword:&lt;/div&gt;&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 bitonic_sort( vec_uint4 Vec ){ static const vec_uchar16 BADC = { 0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b }; static const vec_uchar16 CDAB = { 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }; static const vec_uint4 mask1 = { 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 }; static const vec_uint4 mask2 = { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff }; static const vec_uint4 mask3 = { 0x00000000, 0xffffffff, 0x00000000, 0xffffffff }; vec_uint4 temp, cmp, result; temp = spu_shuffle( Vec_, Vec_, BADC ); // Compare A to B and C to D cmp = spu_cmpgt( Vec_, temp ); cmp = spu_xor( cmp, mask1 ); // Order A/B increasing, C/D decreasing result = spu_sel( Vec_, temp, cmp ); temp = spu_shuffle( result, result, CDAB ); // Compare AB to CD cmp2 = spu_cmpgt( result, temp ); cmp2 = spu_xor( cmp2, mask2 ); // Order AB/CD increasing result = spu_sel( result, temp, cmp2 ); temp = spu_shuffle( result, result, BADC ); // Compare previous A to B and C to D cmp = spu_cmpgt( result, temp ); cmp = spu_xor( cmp, mask3 ); // Order A/B and C/D increasing result = spu_sel( result, temp, cmp ); return result;}&lt;/pre&gt;Next come cmpswap() and cmpswap_skew() from the paper:&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 vector_cmpswap( vec_uint4* A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; const vec_uint4 cmp = spu_cmpgt( a, b ); *A_ = spu_sel( a, b, cmp ); *B_ = spu_sel( b, a, cmp ); return cmp;}inline vec_uint4 vector_cmpswap_skew( vec_uint4 A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; // The last word compared is 0xffff so that part of the mask should always be 0000 static const vec_uchar16 BCDx = { 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xc0, 0xc0, 0xc0, 0xc0 }; const vec_uint4 bShift = spu_shuffle( b, b, BCDx ); const vec_uint4 cmp = spu_cmpgt( a, bShift ); const vec_uint4 swap = spu_sel( a, bShift, cmp ); const vec_uint4 bSwap = spu_sel( bShift, a, cmp ); static const vec_uchar16 abcD = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x0c, 0x0d, 0x0e, 0x0f }; static const vec_uchar16 Aabc = { 0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b }; *A_ = spu_shuffle( a, swap, abcD ); *B_ = spu_shuffle( b, bSwap, Aabc ); return cmp;}&lt;/pre&gt;In both functions I return the comparison mask because I think it’s necessary to implement step 2 of AA-sort’s in-core algorithm; the modified combsort:&lt;pre class=&quot;code&quot;&gt;static const float INV_SHRINK_FACTOR = 1.f/1.3f;uint32_t gap = uint32_t(float(edgeCount) * INV_SHRINK_FACTOR);while (gap &gt; 1){ // Straight comparisons const uint32_t maxSwapIndex = edgeCount - gap; for (uint32_t i = 0; i &lt; maxSwapIndex; ++i) { vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap] ); } // Skewed comparisons for when i+gap exceeds N/4 for (uint32_t i = edgeCount - gap; i &lt; edgeCount; ++i) { vector_cmpswap_skew( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap - edgeCount] ); } gap = uint32_t((float)gap * INV_SHRINK_FACTOR);}vec_uint4 not_sorted;do{ not_sorted = spu_splats((uint32_t)0); for (uint32_t i = 0; i &lt; edgeCount - 1; ++i) { not_sorted = spu_or( not_sorted, vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+1] ) ); } not_sorted = spu_or( not_sorted, vector_cmpswap_skew( (vec_uint4)&amp;work[edgeCount - 1], (vec_uint4*)&amp;work[0] ) ); not_sorted = spu_orx( not_sorted );} while ( spu_extract(not_sorted, 0) );&lt;/pre&gt;I use a shrink factor of 1.3 as suggested by the authors as well the combsort page at Wikipedia. Standard combsort stops looping once gap is less-or-equal to 1 and no swaps have been performed in the current iteration. AA-sort splits the gap and “swap” loops so I use the not_sorted value to keep track of when swaps stop occurring (this is the reason that I return the cmp value from each of the swap() functions).You end up with nicely sorted (albeit transposed) data like:&lt;pre class=&quot;code&quot;&gt;[0] = 00000003 03910392 04a504a6 05140515[1] = 0000002b 03910393 04a604a7 05140516[2] = 0000002b 03910393 04a7049f 05150514[3] = 0000002c 03910394 04a704a8 05150516[4] = 0000002c 03920393 04a704a8 05150516[5] = 0000002d 03930394 04a804a9 05160515[6] = 0003002b 03b903ba 04a9049f 05170516[7] = 00200021 03b903bb 04a904aa 05170518[8] = 00200022 03b903bb 04a904aa 05180517[9] = 00210022 03b903bc 04aa04ab 05190518…&lt;/pre&gt;AA-sort normally calls for a final pass that transposes the elements across the width of each vector rather than through each vector element but it wasn’t necessary in my particular situation.&lt;div&gt;&lt;/div&gt;&lt;div&gt;I took some performance statistics with the decrementer using a few of my data sets and attached the results below:&lt;/div&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Time (ms)&lt;/th&gt;&lt;th&gt;# Values&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.036667&lt;/td&gt;&lt;td&gt;1254&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.008571&lt;/td&gt;&lt;td&gt;171&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.017419&lt;/td&gt;&lt;td&gt;684&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.131654&lt;/td&gt;&lt;td&gt;1902&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.019900&lt;/td&gt;&lt;td&gt;786&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.009424&lt;/td&gt;&lt;td&gt;360&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.109599&lt;/td&gt;&lt;td&gt;954&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.347531&lt;/td&gt;&lt;td&gt;2415&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.371779&lt;/td&gt;&lt;td&gt;2454&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Pretty decent considering the original O(N^2) implementation was taking 3 ms for 2k+ values." />
<meta property="og:description" content="A co-worker sent me a link to AA-sort some time ago, but I didn’t have any reason to use it until just recently. I found myself in a situation where I have 2K~4K 4-byte elements packet into qwords and my initial O(N^2) solution just wasn’t working out. So, I decided to try the O(N log N) “in-core” component of AA-sort as a pre-sort.&lt;div&gt;&lt;/div&gt;&lt;div&gt;The paper linked above is relatively straight-forward, but they only provide pseudo-code so there’s still a bit of effort required to get something usable. As per the author’s goals, it’s easily written as highly-vectorized, non-branching code and was rather fun to get working.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;The authors were working with 8 16-bit values packed into a qword, and I had to make some simple changes to get it working with vec_uint4s.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;First, my bitonic_sort() routine takes care of step one of their in-core algorithm by sorting the 4 uint32t elements in a qword:&lt;/div&gt;&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 bitonic_sort( vec_uint4 Vec ){ static const vec_uchar16 BADC = { 0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b }; static const vec_uchar16 CDAB = { 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }; static const vec_uint4 mask1 = { 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 }; static const vec_uint4 mask2 = { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff }; static const vec_uint4 mask3 = { 0x00000000, 0xffffffff, 0x00000000, 0xffffffff }; vec_uint4 temp, cmp, result; temp = spu_shuffle( Vec_, Vec_, BADC ); // Compare A to B and C to D cmp = spu_cmpgt( Vec_, temp ); cmp = spu_xor( cmp, mask1 ); // Order A/B increasing, C/D decreasing result = spu_sel( Vec_, temp, cmp ); temp = spu_shuffle( result, result, CDAB ); // Compare AB to CD cmp2 = spu_cmpgt( result, temp ); cmp2 = spu_xor( cmp2, mask2 ); // Order AB/CD increasing result = spu_sel( result, temp, cmp2 ); temp = spu_shuffle( result, result, BADC ); // Compare previous A to B and C to D cmp = spu_cmpgt( result, temp ); cmp = spu_xor( cmp, mask3 ); // Order A/B and C/D increasing result = spu_sel( result, temp, cmp ); return result;}&lt;/pre&gt;Next come cmpswap() and cmpswap_skew() from the paper:&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 vector_cmpswap( vec_uint4* A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; const vec_uint4 cmp = spu_cmpgt( a, b ); *A_ = spu_sel( a, b, cmp ); *B_ = spu_sel( b, a, cmp ); return cmp;}inline vec_uint4 vector_cmpswap_skew( vec_uint4 A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; // The last word compared is 0xffff so that part of the mask should always be 0000 static const vec_uchar16 BCDx = { 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xc0, 0xc0, 0xc0, 0xc0 }; const vec_uint4 bShift = spu_shuffle( b, b, BCDx ); const vec_uint4 cmp = spu_cmpgt( a, bShift ); const vec_uint4 swap = spu_sel( a, bShift, cmp ); const vec_uint4 bSwap = spu_sel( bShift, a, cmp ); static const vec_uchar16 abcD = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x0c, 0x0d, 0x0e, 0x0f }; static const vec_uchar16 Aabc = { 0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b }; *A_ = spu_shuffle( a, swap, abcD ); *B_ = spu_shuffle( b, bSwap, Aabc ); return cmp;}&lt;/pre&gt;In both functions I return the comparison mask because I think it’s necessary to implement step 2 of AA-sort’s in-core algorithm; the modified combsort:&lt;pre class=&quot;code&quot;&gt;static const float INV_SHRINK_FACTOR = 1.f/1.3f;uint32_t gap = uint32_t(float(edgeCount) * INV_SHRINK_FACTOR);while (gap &gt; 1){ // Straight comparisons const uint32_t maxSwapIndex = edgeCount - gap; for (uint32_t i = 0; i &lt; maxSwapIndex; ++i) { vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap] ); } // Skewed comparisons for when i+gap exceeds N/4 for (uint32_t i = edgeCount - gap; i &lt; edgeCount; ++i) { vector_cmpswap_skew( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap - edgeCount] ); } gap = uint32_t((float)gap * INV_SHRINK_FACTOR);}vec_uint4 not_sorted;do{ not_sorted = spu_splats((uint32_t)0); for (uint32_t i = 0; i &lt; edgeCount - 1; ++i) { not_sorted = spu_or( not_sorted, vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+1] ) ); } not_sorted = spu_or( not_sorted, vector_cmpswap_skew( (vec_uint4)&amp;work[edgeCount - 1], (vec_uint4*)&amp;work[0] ) ); not_sorted = spu_orx( not_sorted );} while ( spu_extract(not_sorted, 0) );&lt;/pre&gt;I use a shrink factor of 1.3 as suggested by the authors as well the combsort page at Wikipedia. Standard combsort stops looping once gap is less-or-equal to 1 and no swaps have been performed in the current iteration. AA-sort splits the gap and “swap” loops so I use the not_sorted value to keep track of when swaps stop occurring (this is the reason that I return the cmp value from each of the swap() functions).You end up with nicely sorted (albeit transposed) data like:&lt;pre class=&quot;code&quot;&gt;[0] = 00000003 03910392 04a504a6 05140515[1] = 0000002b 03910393 04a604a7 05140516[2] = 0000002b 03910393 04a7049f 05150514[3] = 0000002c 03910394 04a704a8 05150516[4] = 0000002c 03920393 04a704a8 05150516[5] = 0000002d 03930394 04a804a9 05160515[6] = 0003002b 03b903ba 04a9049f 05170516[7] = 00200021 03b903bb 04a904aa 05170518[8] = 00200022 03b903bb 04a904aa 05180517[9] = 00210022 03b903bc 04aa04ab 05190518…&lt;/pre&gt;AA-sort normally calls for a final pass that transposes the elements across the width of each vector rather than through each vector element but it wasn’t necessary in my particular situation.&lt;div&gt;&lt;/div&gt;&lt;div&gt;I took some performance statistics with the decrementer using a few of my data sets and attached the results below:&lt;/div&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Time (ms)&lt;/th&gt;&lt;th&gt;# Values&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.036667&lt;/td&gt;&lt;td&gt;1254&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.008571&lt;/td&gt;&lt;td&gt;171&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.017419&lt;/td&gt;&lt;td&gt;684&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.131654&lt;/td&gt;&lt;td&gt;1902&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.019900&lt;/td&gt;&lt;td&gt;786&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.009424&lt;/td&gt;&lt;td&gt;360&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.109599&lt;/td&gt;&lt;td&gt;954&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.347531&lt;/td&gt;&lt;td&gt;2415&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.371779&lt;/td&gt;&lt;td&gt;2454&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Pretty decent considering the original O(N^2) implementation was taking 3 ms for 2k+ values." />
<link rel="canonical" href="https://rendered-obsolete.bitbucket.io/2009/02/13/aa-sort.html" />
<meta property="og:url" content="https://rendered-obsolete.bitbucket.io/2009/02/13/aa-sort.html" />
<meta property="og:site_name" content="Rendered Obsolete" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2009-02-13T21:35:00+08:00" />
<script type="application/ld+json">
{"description":"A co-worker sent me a link to AA-sort some time ago, but I didn’t have any reason to use it until just recently. I found myself in a situation where I have 2K~4K 4-byte elements packet into qwords and my initial O(N^2) solution just wasn’t working out. So, I decided to try the O(N log N) “in-core” component of AA-sort as a pre-sort.&lt;div&gt;&lt;/div&gt;&lt;div&gt;The paper linked above is relatively straight-forward, but they only provide pseudo-code so there’s still a bit of effort required to get something usable. As per the author’s goals, it’s easily written as highly-vectorized, non-branching code and was rather fun to get working.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;The authors were working with 8 16-bit values packed into a qword, and I had to make some simple changes to get it working with vec_uint4s.&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;First, my bitonic_sort() routine takes care of step one of their in-core algorithm by sorting the 4 uint32t elements in a qword:&lt;/div&gt;&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 bitonic_sort( vec_uint4 Vec ){ static const vec_uchar16 BADC = { 0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03, 0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b }; static const vec_uchar16 CDAB = { 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }; static const vec_uint4 mask1 = { 0x00000000, 0xffffffff, 0xffffffff, 0x00000000 }; static const vec_uint4 mask2 = { 0x00000000, 0x00000000, 0xffffffff, 0xffffffff }; static const vec_uint4 mask3 = { 0x00000000, 0xffffffff, 0x00000000, 0xffffffff }; vec_uint4 temp, cmp, result; temp = spu_shuffle( Vec_, Vec_, BADC ); // Compare A to B and C to D cmp = spu_cmpgt( Vec_, temp ); cmp = spu_xor( cmp, mask1 ); // Order A/B increasing, C/D decreasing result = spu_sel( Vec_, temp, cmp ); temp = spu_shuffle( result, result, CDAB ); // Compare AB to CD cmp2 = spu_cmpgt( result, temp ); cmp2 = spu_xor( cmp2, mask2 ); // Order AB/CD increasing result = spu_sel( result, temp, cmp2 ); temp = spu_shuffle( result, result, BADC ); // Compare previous A to B and C to D cmp = spu_cmpgt( result, temp ); cmp = spu_xor( cmp, mask3 ); // Order A/B and C/D increasing result = spu_sel( result, temp, cmp ); return result;}&lt;/pre&gt;Next come cmpswap() and cmpswap_skew() from the paper:&lt;pre class=&quot;code&quot;&gt;inline vec_uint4 vector_cmpswap( vec_uint4* A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; const vec_uint4 cmp = spu_cmpgt( a, b ); *A_ = spu_sel( a, b, cmp ); *B_ = spu_sel( b, a, cmp ); return cmp;}inline vec_uint4 vector_cmpswap_skew( vec_uint4 A_, vec_uint4* B_ ){ const vec_uint4 a = A_; const vec_uint4 b = *B_; // The last word compared is 0xffff so that part of the mask should always be 0000 static const vec_uchar16 BCDx = { 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xc0, 0xc0, 0xc0, 0xc0 }; const vec_uint4 bShift = spu_shuffle( b, b, BCDx ); const vec_uint4 cmp = spu_cmpgt( a, bShift ); const vec_uint4 swap = spu_sel( a, bShift, cmp ); const vec_uint4 bSwap = spu_sel( bShift, a, cmp ); static const vec_uchar16 abcD = { 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x0c, 0x0d, 0x0e, 0x0f }; static const vec_uchar16 Aabc = { 0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b }; *A_ = spu_shuffle( a, swap, abcD ); *B_ = spu_shuffle( b, bSwap, Aabc ); return cmp;}&lt;/pre&gt;In both functions I return the comparison mask because I think it’s necessary to implement step 2 of AA-sort’s in-core algorithm; the modified combsort:&lt;pre class=&quot;code&quot;&gt;static const float INV_SHRINK_FACTOR = 1.f/1.3f;uint32_t gap = uint32_t(float(edgeCount) * INV_SHRINK_FACTOR);while (gap &gt; 1){ // Straight comparisons const uint32_t maxSwapIndex = edgeCount - gap; for (uint32_t i = 0; i &lt; maxSwapIndex; ++i) { vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap] ); } // Skewed comparisons for when i+gap exceeds N/4 for (uint32_t i = edgeCount - gap; i &lt; edgeCount; ++i) { vector_cmpswap_skew( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+gap - edgeCount] ); } gap = uint32_t((float)gap * INV_SHRINK_FACTOR);}vec_uint4 not_sorted;do{ not_sorted = spu_splats((uint32_t)0); for (uint32_t i = 0; i &lt; edgeCount - 1; ++i) { not_sorted = spu_or( not_sorted, vector_cmpswap( (vec_uint4)&amp;work[i], (vec_uint4)&amp;work[i+1] ) ); } not_sorted = spu_or( not_sorted, vector_cmpswap_skew( (vec_uint4)&amp;work[edgeCount - 1], (vec_uint4*)&amp;work[0] ) ); not_sorted = spu_orx( not_sorted );} while ( spu_extract(not_sorted, 0) );&lt;/pre&gt;I use a shrink factor of 1.3 as suggested by the authors as well the combsort page at Wikipedia. Standard combsort stops looping once gap is less-or-equal to 1 and no swaps have been performed in the current iteration. AA-sort splits the gap and “swap” loops so I use the not_sorted value to keep track of when swaps stop occurring (this is the reason that I return the cmp value from each of the swap() functions).You end up with nicely sorted (albeit transposed) data like:&lt;pre class=&quot;code&quot;&gt;[0] = 00000003 03910392 04a504a6 05140515[1] = 0000002b 03910393 04a604a7 05140516[2] = 0000002b 03910393 04a7049f 05150514[3] = 0000002c 03910394 04a704a8 05150516[4] = 0000002c 03920393 04a704a8 05150516[5] = 0000002d 03930394 04a804a9 05160515[6] = 0003002b 03b903ba 04a9049f 05170516[7] = 00200021 03b903bb 04a904aa 05170518[8] = 00200022 03b903bb 04a904aa 05180517[9] = 00210022 03b903bc 04aa04ab 05190518…&lt;/pre&gt;AA-sort normally calls for a final pass that transposes the elements across the width of each vector rather than through each vector element but it wasn’t necessary in my particular situation.&lt;div&gt;&lt;/div&gt;&lt;div&gt;I took some performance statistics with the decrementer using a few of my data sets and attached the results below:&lt;/div&gt;&lt;table border=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;Time (ms)&lt;/th&gt;&lt;th&gt;# Values&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.036667&lt;/td&gt;&lt;td&gt;1254&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.008571&lt;/td&gt;&lt;td&gt;171&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.017419&lt;/td&gt;&lt;td&gt;684&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.131654&lt;/td&gt;&lt;td&gt;1902&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.019900&lt;/td&gt;&lt;td&gt;786&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.009424&lt;/td&gt;&lt;td&gt;360&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.109599&lt;/td&gt;&lt;td&gt;954&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.347531&lt;/td&gt;&lt;td&gt;2415&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0.371779&lt;/td&gt;&lt;td&gt;2454&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;Pretty decent considering the original O(N^2) implementation was taking 3 ms for 2k+ values.","author":{"@type":"Person","name":"Contact:"},"@type":"BlogPosting","url":"https://rendered-obsolete.bitbucket.io/2009/02/13/aa-sort.html","headline":"AA-sort","dateModified":"2009-02-13T21:35:00+08:00","datePublished":"2009-02-13T21:35:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://rendered-obsolete.bitbucket.io/2009/02/13/aa-sort.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link rel="stylesheet" href="/assets/main.css">
  <link type="application/atom+xml" rel="alternate" href="https://rendered-obsolete.bitbucket.io/feed.xml" title="Rendered Obsolete" />
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" rel="author" href="/">Rendered Obsolete</a>

    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/about/">About</a>
            
          
            
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">AA-sort</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2009-02-13T21:35:00+08:00" itemprop="datePublished">
        
        Feb 13, 2009
      </time>
      
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Contact:</span></span>
      </p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    A co-worker sent me a link to <a href="http://www.trl.ibm.com/people/inouehrs/pdf/PACT2007-SIMDsort.pdf">AA-sort</a> some time ago, but I didn't have any reason to use it until just recently.  I found myself in a situation where I have 2K~4K 4-byte elements packet into qwords and my initial O(N^2) solution just wasn't working out.  So, I decided to try the O(N log N) "in-core" component of AA-sort as a pre-sort.<div><br /></div><div>The paper linked above is relatively straight-forward, but they only provide pseudo-code so there's still a bit of effort required to get something usable.  As per the author's goals, it's easily written as highly-vectorized, non-branching code and was rather fun to get working.</div><div><br /></div><div>The authors were working with 8 16-bit values packed into a qword, and I had to make some simple changes to get it working with vec_uint4s.</div><div><br /></div><div>First, my bitonic_sort() routine takes care of step one of their in-core algorithm by sorting the 4 uint32_t elements in a qword:</div><br /><pre class="code">inline vec_uint4 bitonic_sort( vec_uint4 Vec_ )<br />{<br />   static const vec_uchar16 BADC = {<br />       0x04, 0x05, 0x06, 0x07, 0x00, 0x01, 0x02, 0x03,<br />       0x0c, 0x0d, 0x0e, 0x0f, 0x08, 0x09, 0x0a, 0x0b<br />   };<br />   static const vec_uchar16 CDAB = {<br />       0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,<br />       0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07<br />   };<br />   static const vec_uint4 mask1 = {<br />       0x00000000, 0xffffffff, 0xffffffff, 0x00000000<br />   };<br />   static const vec_uint4 mask2 = {<br />       0x00000000, 0x00000000, 0xffffffff, 0xffffffff<br />   };<br />   static const vec_uint4 mask3 = {<br />       0x00000000, 0xffffffff, 0x00000000, 0xffffffff<br />   };<br />   vec_uint4 temp, cmp, result;<br /><br />   temp = spu_shuffle( Vec_, Vec_, BADC ); // Compare A to B and C to D<br />   cmp = spu_cmpgt( Vec_, temp );<br />   cmp = spu_xor( cmp, mask1 ); // Order A/B increasing, C/D decreasing<br />   result = spu_sel( Vec_, temp, cmp );<br /><br />   temp = spu_shuffle( result, result, CDAB ); // Compare AB to CD<br />   cmp2 = spu_cmpgt( result, temp );<br />   cmp2 = spu_xor( cmp2, mask2 ); // Order AB/CD increasing<br />   result = spu_sel( result, temp, cmp2 );<br />   temp = spu_shuffle( result, result, BADC ); // Compare previous A to B and C to D<br />   cmp = spu_cmpgt( result, temp );<br />   cmp = spu_xor( cmp, mask3 ); // Order A/B and C/D increasing<br />   result = spu_sel( result, temp, cmp );<br /><br />   return result;<br />}<br /></pre><br />Next come cmpswap() and cmpswap_skew() from the paper:<br /><br /><pre class="code">inline vec_uint4 vector_cmpswap( vec_uint4* A_, vec_uint4* B_ )<br />{<br />   const vec_uint4 a = *A_;<br />   const vec_uint4 b = *B_;<br />   const vec_uint4 cmp = spu_cmpgt( a, b );<br />   *A_ = spu_sel( a, b, cmp );<br />   *B_ = spu_sel( b, a, cmp );<br /><br />   return cmp;<br />}<br /><br />inline vec_uint4 vector_cmpswap_skew( vec_uint4* A_, vec_uint4* B_ )<br />{<br />   const vec_uint4 a = *A_;<br />   const vec_uint4 b = *B_;<br /><br />   // The last word compared is 0xffff so that part of the mask should always be 0000<br />   static const vec_uchar16 BCDx = {<br />       0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,<br />       0x0c, 0x0d, 0x0e, 0x0f, 0xc0, 0xc0, 0xc0, 0xc0<br />   };<br />   const vec_uint4 bShift = spu_shuffle( b, b, BCDx );<br />   const vec_uint4 cmp = spu_cmpgt( a, bShift );<br />   const vec_uint4 swap = spu_sel( a, bShift, cmp );<br />   const vec_uint4 bSwap = spu_sel( bShift, a, cmp );<br /><br />   static const vec_uchar16 abcD = {<br />       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,<br />       0x18, 0x19, 0x1a, 0x1b, 0x0c, 0x0d, 0x0e, 0x0f<br />   };<br />   static const vec_uchar16 Aabc = {<br />       0x00, 0x01, 0x02, 0x03, 0x10, 0x11, 0x12, 0x13,<br />       0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b<br />   };<br />   *A_ = spu_shuffle( a, swap, abcD );<br />   *B_ = spu_shuffle( b, bSwap, Aabc );<br /><br />   return cmp;<br />}<br /></pre><br />In both functions I return the comparison mask because I think it's necessary to implement step 2 of AA-sort's in-core algorithm; the modified combsort:<br /><br /><pre class="code">static const float INV_SHRINK_FACTOR = 1.f/1.3f;<br />uint32_t gap = uint32_t(float(edgeCount) * INV_SHRINK_FACTOR);<br />while (gap &gt; 1)<br />{<br />   // Straight comparisons<br />   const uint32_t maxSwapIndex = edgeCount - gap;<br />   for (uint32_t i = 0; i &lt; maxSwapIndex; ++i)<br />   {<br />       vector_cmpswap( (vec_uint4*)&amp;work[i], (vec_uint4*)&amp;work[i+gap] );<br />   }<br /><br />   // Skewed comparisons for when i+gap exceeds N/4<br />   for (uint32_t i = edgeCount - gap; i &lt; edgeCount; ++i)<br />   {<br />       vector_cmpswap_skew( (vec_uint4*)&amp;work[i], (vec_uint4*)&amp;work[i+gap - edgeCount] );<br />   }<br /><br />   gap = uint32_t((float)gap * INV_SHRINK_FACTOR);<br />}<br />vec_uint4 not_sorted;<br />do<br />{<br />   not_sorted = spu_splats((uint32_t)0);<br />   for (uint32_t i = 0; i &lt; edgeCount - 1; ++i)<br />   {<br />       not_sorted = spu_or( not_sorted, vector_cmpswap( (vec_uint4*)&amp;work[i], (vec_uint4*)&amp;work[i+1] ) );<br />   }<br />   not_sorted = spu_or( not_sorted, vector_cmpswap_skew( (vec_uint4*)&amp;work[edgeCount - 1], (vec_uint4*)&amp;work[0] ) );<br />   not_sorted = spu_orx( not_sorted );<br />} while ( spu_extract(not_sorted, 0) );<br /></pre><br />I use a shrink factor of 1.3 as suggested by the authors as well the <a href="http://en.wikipedia.org/wiki/Combsort">combsort page at Wikipedia</a>.  Standard combsort stops looping once <i>gap</i> is less-or-equal to 1 and no swaps have been performed in the current iteration.  AA-sort splits the <i>gap</i> and "swap" loops so I use the <i>not_sorted</i> value to keep track of when swaps stop occurring (this is the reason that I return the <i>cmp</i> value from each of the swap() functions).<br /><br />You end up with nicely sorted (albeit transposed) data like:<br /><br /><pre class="code">[0] = 00000003 03910392 04a504a6 05140515<br />[1] = 0000002b 03910393 04a604a7 05140516<br />[2] = 0000002b 03910393 04a7049f 05150514<br />[3] = 0000002c 03910394 04a704a8 05150516<br />[4] = 0000002c 03920393 04a704a8 05150516<br />[5] = 0000002d 03930394 04a804a9 05160515<br />[6] = 0003002b 03b903ba 04a9049f 05170516<br />[7] = 00200021 03b903bb 04a904aa 05170518<br />[8] = 00200022 03b903bb 04a904aa 05180517<br />[9] = 00210022 03b903bc 04aa04ab 05190518<br />...<br /></pre><br />AA-sort normally calls for a final pass that transposes the elements across the width of each vector rather than through each vector element but it wasn't necessary in my particular situation.<div><br /></div><div>I took some performance statistics with the decrementer using a few of my data sets and attached the results below:</div><br /><br /><table border="1"><tr><th>Time (ms)</th><th># Values</th></tr><tr><td>0.036667</td><td>1254</td></tr><tr><td>0.008571</td><td>171</td></tr><tr><td>0.017419</td><td>684</td></tr><tr><td>0.131654</td><td>1902</td></tr><tr><td>0.019900</td><td>786</td></tr><tr><td>0.009424</td><td>360</td></tr><tr><td>0.109599</td><td>954</td></tr><tr><td>0.347531</td><td>2415</td></tr><tr><td>0.371779</td><td>2454</td></tr></table><br /><br />Pretty decent considering the original O(N^2) implementation was taking 3 ms for 2k+ values.
  </div>

  

  <a class="u-url" href="/2009/02/13/aa-sort.html" hidden></a>
</article>

      </div>
    </main>

    <footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Rendered Obsolete</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            
              Rendered Obsolete
            
            </li>
            
            <li><a class="u-email" href="mailto:renderedobsolete@gmail.com">renderedobsolete@gmail.com</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
  
  
  
  
  
  
  
  
  
  
  
</ul>

      </div>

      <div class="footer-col footer-col-3">
        <p>A clever description for Google search results and RSS feed.</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
