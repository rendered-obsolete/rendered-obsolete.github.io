---
layout: post
title: The Rising Tide of Alt Languages
date: '2016-03-05T17:49:00.003+09:00'
author: 'Contact:'
tags:
- lang
- rant
modified_time: '2016-03-05T17:49:49.324+09:00'
blogger_id: tag:blogger.com,1999:blog-5371326417913853395.post-5781619273169103728
blogger_orig_url: http://rendered-obsolete.blogspot.com/2016/03/the-rising-tide-of-alt-languages.html
---

We're in some kind of renaissance of programming languages.  When I was first starting out I'd used a few languages (Basic, Pascal, C, a porpourri of assembly dialects), but the lack of Internet prevented me from knowing about all the miscellaneous toy "research" languages and I was only vaguely aware of Fortran/Cobol and so on.  In Uni I was exposed to Java, VHDL, Scheme, Python, and a few more assembly dialects.  <p/> But upon graduating, for years and years I regarded myself as a snooty, elitist c++ programmer.  Besides occasional forays into Python or (eventually) c# for doing "scripting" or maybe making tools, I accepted that all <em>real</em> work was done with c++.  Other languages were relegated to fooling around, teaching children, or "web programming"- and a select few (Perl) seemed to be specifically designed to torment people.  After years of in-house engines, the horrors of UE3/CryEngine, etc. it took a few prototypes with <a href="https://unity3d.com/">Unity3D</a> to make me see the errors of my ways.  My university professors were correct; "software engineering" was about a lot more than banging out code and sweet macro shenanigans.  <p/> More recently, JavaScript- which in my mind is still closely associated 90's-era "mouseover" events- came back on the radar on account of the <a href="https://nodejs.org">Node.js</a> juggernaut.  Only this time it wasn't just for throw away web clients, it was for servers too.  And, while I've still yet to look into it, I am aware that it is a <em>thing</em>.  And a big one at that.  <p/> As part of Microsoft's increasingly virile affair with open source and multi-platform love-ins they released <a href="https://code.visualstudio.com/">Visual Studio Code</a>.  After a bit of rummaging around, I was shocked to find out it too was made in JavaScript with a framework called <a href="http://electron.atom.io/">Electron</a>.  Poking around their website uncovered a number of interesting platforms for developing apps/games like <a href="http://www.pixate.com/">pixate</a>, <a href="http://ionic.io/">ionic</a>, <a href="http://fireball-x.com/en/">fireball</a>, and <a href="http://superpowers-html5.com/index.en.html">superpowers</a>.  All of which I think of as the "next-generation" app/game development tools- similar to <a href="http://www.maxplay.io/">MaxPlay</a> (which specifically mentions Electron in a <a href="http://maxplay.applytojob.com/apply/aOlOn0/Software-Engineer">Software Engineer job posting</a>).  <p/> I've been infatuated with <a href="http://fsharp.org/">F#</a> for a while now.  It had this sudden-outbreak-of-common-sense freshness about it: options, statically typed with powerful type inference, interoperability with c#, asynchronous computation expressions (monads), and other cornerstones of the functional world.  But maybe I'd just grown tired of OO programming; it was getting a bit old and fat and FP was new hotness.  Or, the old is new again, rather.  Used it for a pair of backend prototypes but nothing in production.  Somehow I can't justify subjecting other people to the OCaml/ML universe just because it amuses me.  <p/> For a while we were evaluating <a href="https://golang.org/">golang</a> for constructing our new backend.  Partially swept up by it's apparently burgeoning popularity in China, we were specifically motivated by the experiences of <a href="https://blog.golang.org/qihoo">Qihoo</a> et al.  I was also intrigued by the kind of <a href="http://benchmarksgame.alioth.debian.org/">performance numbers</a> they were claiming (TODO: add disclaimer regarding benchmarks and contrived tests and real-world performance blah blah blah).  I was pleased with their sensible approach to errors and how easy it was to get a working program, but more than a little disappointed with their insistence on flip-flopping between (IMHO) <a href="https://golang.org/doc/faq">overly opinionated design decisions</a> and embracing horrific mistakes like void* and <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">the</a> <a href="https://en.wikipedia.org/wiki/Tony_Hoare">null</a>.  <p/> I've been spending some of my free time toying around with <a href="https://www.rust-lang.org/">Rust</a>.  I've probably started reading <a href="https://doc.rust-lang.org/book/">The Book</a> or futzed with <a href="http://rustbyexample.com/">Rust By Example</a> 2 or 3 times now.  But, I get busy or distracted and put it aside for a month or two such that I never really <em>get it</em> and am still sufficiently noob that I spend most of my time fighting with the compiler.  Maybe it's too strict... or maybe I need to stop trying to write c++ with it.  <p/> While we're on the topic of c++ "killers", let's not write out Java just yet.  Despite my expectations that Oracle would succeed in smothering it, it's instead staged a comeback and clawed itself to the <a href="http://www.tiobe.com/tiobe_index">top of the Tiobe index</a>.  It's also being used (along with <a href="http://akka.io/">Akka</a>) for the backend being developed in parallel by one of our other teams.  <p/> As a final note, it's difficult to bring up f#, golang, and rust without giving a shoutout to the numerous other languages that are often mentioned in the same breath: <a href="http://julialang.org/">julia</a>, <a href="http://kotlinlang.org/">kotlin</a>, <a href="http://www.scala-lang.org/">scala</a>, <a href="http://nimrod-lang.org/">nimrod</a>, and numerous others.  There really isn't enough time in a day to investigate them all to a satisfactory level.  <p/> Exciting stuff.